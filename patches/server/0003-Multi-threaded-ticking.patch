From 19478212af1a2ce321caf87dd1d7e2545ec4029f Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 18 Dec 2018 04:24:08 -0800
Subject: [PATCH] Multi-threaded ticking

This is the patch for vanilla side only
---
 .../concrete/chunk/ChunkRegionManager.java    | 124 ++++++++++++++++++
 1 file changed, 124 insertions(+)
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java

diff --git a/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
new file mode 100644
index 000000000..012e6c7fd
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
@@ -0,0 +1,124 @@
+package io.github.spottedleaf.concrete.chunk;
+
+import io.github.spottedleaf.concurrentutil.queue.ConcurrentLinkedList;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.server.Chunk;
+
+import java.nio.file.Files;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Consumer;
+
+public class ChunkRegionManager {
+
+    public final Long2ObjectOpenHashMap<ChunkRegion> regions = new Long2ObjectOpenHashMap<>(2048);
+
+    public static long getChunkKey(final int x, final int z) {
+        return ((long)z << 32) | (x & 0xFFFFFFFFL);
+    }
+
+    public static int getChunkX(final long key) {
+        return (int)key;
+    }
+
+    public static int getChunkZ(final long key) {
+        return (int)(key >>> 32);
+    }
+
+    public ChunkRegion acquireRegionSynchronously(final long chunk) {
+        return null;
+    }
+
+    public void acquireRegionAsynchronously(final Consumer<ChunkRegion> region) {
+
+    }
+
+    /**
+     * Removes the specified chunk from this region manager. This function presumes no chunks can be removed or
+     * added concurrently. That is, chunks are only removed by a single thread at the end of a tick.
+     * <p>
+     * This function is not MT-Safe.
+     * </p>
+     * @param chunk The specified chunk.
+     */
+    public void removeChunk(final Chunk chunk) {
+
+    }
+
+    public static class ChunkRegion {
+
+        public final ChunkRegionManager regionManager;
+
+        private final ReentrantLock lock = new ReentrantLock();
+
+        private final Long2ObjectOpenHashMap<Chunk> chunks = new Long2ObjectOpenHashMap<>();
+
+        /**
+         * Tasks that need to be executed after releasing the region.
+         */
+        private final ConcurrentLinkedList<Consumer<ChunkRegion>> tasks = new ConcurrentLinkedList<>();
+
+        public ChunkRegion(final ChunkRegionManager regionManager) {
+            this.regionManager = regionManager;
+            this.tasks.preventAdds(); /* Required since an add-blocked queue represents a free region */
+        }
+
+        public void addChunk(final Chunk chunk) {
+
+        }
+
+        public void removeChunk(final Chunk chunk) {
+
+        }
+
+        public int chunkConut() {
+            return this.chunks.size();
+        }
+
+        private void drainTasks() {
+            this.tasks.drain((final Consumer<ChunkRegion> consumer) -> {
+                consumer.accept(ChunkRegion.this);
+            },true);
+        }
+
+        public void releaseLock() {
+            if (this.lock.getHoldCount() == 1) {
+                /* This is required to prevent a race condition where a task is executed on a tick segment later than it is expected */
+                this.drainTasks();
+            }
+            this.lock.unlock();
+        }
+
+        public void acquireLock() {
+            this.lock.lock();
+            if (this.lock.getHoldCount() == 1) {
+                this.tasks.allowAdds();
+            }
+        }
+
+        public boolean tryAcquireLock() {
+            if (!this.lock.tryLock()) {
+                return false;
+            }
+            if (this.lock.getHoldCount() == 1) {
+                this.tasks.allowAdds();
+            }
+            return true;
+        }
+
+        public boolean executeNonUrgentTask(final Consumer<ChunkRegion> consumer) {
+            for (;;) {
+                /* Either successfully add to wait queue or lock the region */
+                /* Note that order here matters, threads already owning a region should execute its task synchronously! */
+                if (this.tryAcquireLock()) {
+                    consumer.accept(this);
+                    this.releaseLock();
+                    return true;
+                } else if (this.tasks.add(consumer)) {
+                    return false;
+                }
+                /* Failure means retry, one has to eventually work (and we only reach this point due to a rare race condition) */
+            }
+        }
+
+    }
+}
\ No newline at end of file
-- 
2.20.1

