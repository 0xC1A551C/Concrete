From 187bdf8b6a0db88b80a8ea1939b080066482fa59 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 18 Dec 2018 04:24:08 -0800
Subject: [PATCH] Multi-Threaded chunk ticking

---
 pom.xml                                       |   4 +-
 .../concrete/chunk/ChunkRegionManager.java    |  19 +
 .../concurrent/ConcurrentArrayQueue.java      | 402 +++++++++++
 .../concurrent/ConcurrentLinkedList.java      | 654 ++++++++++++++++++
 .../concrete/concurrent/ConcurrentUtil.java   |  39 ++
 .../concrete/util/IntegerUtil.java            |  31 +
 6 files changed, 1147 insertions(+), 2 deletions(-)
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java

diff --git a/pom.xml b/pom.xml
index f86550347..51bbb61ed 100644
--- a/pom.xml
+++ b/pom.xml
@@ -16,8 +16,8 @@
         <buildtag.prefix>git-Bukkit-</buildtag.prefix>
         <buildtag.suffix></buildtag.suffix>
         <maven.build.timestamp.format>yyyyMMdd-HHmm</maven.build.timestamp.format>
-        <maven.compiler.source>1.8</maven.compiler.source>
-        <maven.compiler.target>1.8</maven.compiler.target>
+        <maven.compiler.source>11</maven.compiler.source>
+        <maven.compiler.target>11</maven.compiler.target>
     </properties>
 
     <parent>
diff --git a/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
new file mode 100644
index 000000000..7c76d6556
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
@@ -0,0 +1,19 @@
+package io.github.spottedleaf.concrete.chunk;
+
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+
+public class ChunkRegionManager {
+
+    private final Long2ObjectOpenHashMap<ChunkRegionReference> regions = new Long2ObjectOpenHashMap<>();
+
+    public class ChunkRegion {
+
+    }
+
+    public class ChunkRegionReference {
+
+        public ChunkRegion reference;
+
+    }
+
+}
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
new file mode 100644
index 000000000..5d80c6853
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
@@ -0,0 +1,402 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+import io.github.spottedleaf.concrete.util.IntegerUtil;
+
+import java.lang.invoke.VarHandle;
+import java.util.Arrays;
+
+public final class ConcurrentArrayQueue<E> {
+
+    public static final int NORESIZE_FLAG = (1 << 0);
+    public static final int PEEK_FLAG     = (1 << 1);
+
+    private static final int UINT_MAX = -1;
+    private static final int MAX_INDEX = UINT_MAX >>> 2; /* 1 bit for encoded length, 1 bit for resize flag */
+    private static final int MAX_LENGTH = MAX_INDEX + 1;
+    private static final int INDEX_LENGTH_MASK = MAX_INDEX | MAX_LENGTH;
+
+    private static final int READING_BIT = Integer.MIN_VALUE;
+
+    private Object[] elements; /* access synchronized through indices */
+
+    private volatile int headIndex;
+    private volatile int availableTailIndex;
+    private volatile int allocatedTailIndex;
+
+    private static final VarHandle HEAD_INDEX_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentArrayQueue.class, "headIndex", int.class);
+    private static final VarHandle AVAILABLE_TAIL_INDEX_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentArrayQueue.class, "availableTailIndex", int.class);
+    private static final VarHandle ALLOCATED_TAIL_INDEX_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentArrayQueue.class, "allocatedTailIndex", int.class);
+
+    public ConcurrentArrayQueue() {
+        this(32);
+    }
+
+    public ConcurrentArrayQueue(int capacity) {
+        if (capacity < 0 || capacity > MAX_LENGTH) {
+            throw new IllegalArgumentException("Capacity " + capacity + " is out of bounds");
+        } else if (capacity <= 32) {
+            capacity = 32;
+        } else {
+            final int prevCapacity = capacity;
+            capacity = IntegerUtil.roundCeilLog2(capacity);
+            if (capacity > MAX_LENGTH) {
+                throw new IllegalArgumentException("Capacity " + prevCapacity + " is out of bounds");
+            }
+        }
+
+        this.elements = new Object[capacity];
+        HEAD_INDEX_HANDLE.set(this, capacity);
+        AVAILABLE_TAIL_INDEX_HANDLE.set(this, capacity);
+        ALLOCATED_TAIL_INDEX_HANDLE.set(this, capacity);
+    }
+
+    /* Inclusive head, Exclusive tail */
+    private static int queueLength(final int head, final int tail, final int lengthMask) {
+        return (tail - head) & lengthMask;
+    }
+
+    /* Inclusive head, Exclusive tail */
+    private static int getRemainingLength(final int head, final int tail, final int length) {
+        if (head <= tail) {
+            return length - (tail - head);
+        } else {
+            return (head - tail);
+        }
+    }
+
+    public int capacity(final int flags) {
+        int failures = 0;
+        for (;;) {
+            final int tail = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return IntegerUtil.roundFloorLog2(tail);
+        }
+    }
+
+    public int size() {
+        int failures = 0;
+        for (;;) {
+            int head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+            final int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);
+
+            if (head == UINT_MAX) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            head &= INDEX_LENGTH_MASK;
+
+            final int lengthHead = IntegerUtil.roundFloorLog2(head);
+            final int lengthTail = IntegerUtil.roundFloorLog2(tail);
+
+            if (lengthHead != lengthTail) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return queueLength(head ^ lengthHead, tail ^ lengthTail, lengthHead - 1);
+        }
+    }
+
+    public int remainingCapacity() {
+        int failures = 0;
+        for (;;) {
+            int head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+            final int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);
+
+            if (head == UINT_MAX) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            head &= INDEX_LENGTH_MASK;
+
+            final int lengthHead = IntegerUtil.roundFloorLog2(head);
+            final int lengthTail = IntegerUtil.roundFloorLog2(tail);
+
+            if (lengthHead != lengthTail) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return getRemainingLength(head ^ lengthHead, tail ^ lengthTail, lengthHead);
+        }
+    }
+
+    public int read(final E[] buffer, final int maxItems, final int flags) {
+        int head;
+        if ((flags & NORESIZE_FLAG) != 0) {
+            head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+        } else {
+            for (int failures = 0;;++failures) {
+                head = (int)HEAD_INDEX_HANDLE.getAndBitwiseOr(this, READING_BIT);
+                if (head != UINT_MAX) {
+                    break;
+                }
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+            }
+        }
+
+        /* Since writes to tail are seq_cst, and sychronization already occured, tail is pretty up-to-date */
+        /* Use acquire to synchronize with the state at tail's point in time */
+        int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);
+
+        /* By locking the head it is guaranteed the tail will have the same length as head */
+        final Object[] elements = this.elements;
+
+        final int length = IntegerUtil.roundFloorLog2(head);
+        final int lengthMask = length - 1;
+
+        tail ^= length;
+        head ^= length;
+
+        int itemsToRead = queueLength(head, tail, lengthMask);
+
+        if (itemsToRead >= maxItems) {
+            itemsToRead = maxItems;
+        }
+
+        final int newHead = (head + itemsToRead) & lengthMask;
+
+        if (buffer != null) {
+            if (newHead >= head) {
+                /* Sequential */
+                System.arraycopy(elements, head, (Object[])buffer, 0, itemsToRead);
+                if ((flags & PEEK_FLAG) == 0) {
+                    Arrays.fill(elements, head, head + itemsToRead, null);
+                }
+            } else {
+                /* Wrapped */
+                final int end = length - head;
+                if ((flags & PEEK_FLAG) != 0) {
+                    System.arraycopy(elements, head, (Object[]) buffer, 0, end);
+                    System.arraycopy(elements, 0, (Object[]) buffer, end, itemsToRead - end);
+                } else {
+                    System.arraycopy(elements, head, (Object[]) buffer, 0, end);
+                    Arrays.fill(elements, head, head + end, null);
+                    System.arraycopy(elements, 0, (Object[]) buffer, end, itemsToRead - end);
+                    Arrays.fill(elements, 0, itemsToRead - end, null);
+                }
+            }
+        }
+
+        if ((flags & PEEK_FLAG) != 0) {
+            /* Only write when there is a need to */
+            if ((flags & NORESIZE_FLAG) == 0) {
+                HEAD_INDEX_HANDLE.setVolatile(this, head | length);
+            }
+        } else {
+            HEAD_INDEX_HANDLE.setVolatile(this, newHead | length);
+        }
+
+        return itemsToRead;
+    }
+
+
+    @SafeVarargs
+    public final int add(final E... elements) {
+        return this.add(elements, 0, elements.length, 0);
+    }
+
+    public int add(final E[] elements, final int off, final int nitems, final int flags) {
+        final int maxLength = MAX_LENGTH;
+
+        if (nitems >= maxLength) {
+            throw new IllegalArgumentException("nitems is too large: " + nitems);
+        }
+
+        int currentIndex;
+        int failures = 0;
+        for (;;) {
+            /* Exponential backoff */
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+
+            /* Retrieve current_index after backoff to ensure it's not immediately out-of-date */
+            currentIndex = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+
+            if (currentIndex == UINT_MAX) {
+                Thread.yield();
+                currentIndex = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+            }
+
+            /* Not resizing */
+
+            /* Decode length */
+            final int length = IntegerUtil.roundFloorLog2(currentIndex);
+            final int lengthMask = length - 1;
+
+            final int allocatedStart = currentIndex ^ length; /* Inclusive */
+            final int allocatedEnd = (currentIndex + nitems) & lengthMask; /* Exclusive */
+
+            final int currentHeadRaw = (int)HEAD_INDEX_HANDLE.getAcquire(this);
+
+            /* Validate the indices */
+
+            /*
+             * May not be resizing
+             * Must have equal encoded lengths (otherwise size check is invalid)
+             */
+
+            if (currentHeadRaw == UINT_MAX) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+            if (IntegerUtil.roundFloorLog2(currentHeadRaw & INDEX_LENGTH_MASK) != length) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            /* Finished validating the head index */
+
+            final int queueStart = currentHeadRaw & lengthMask; /* Inclusive */
+
+            /* Find remaining length to ensure there is enough space */
+            final int remainingLength = getRemainingLength(queueStart, allocatedStart, length);
+
+            if (remainingLength > nitems) {
+                /* space available */
+                if (!ALLOCATED_TAIL_INDEX_HANDLE.compareAndSet(this, currentIndex, allocatedEnd | length)) {
+                    ++failures;
+                    continue;
+                }
+
+                final Object[] queuedElements = this.elements;
+                if (allocatedEnd >= allocatedStart) {
+                    /* Sequential */
+                    System.arraycopy((Object[])elements, off, queuedElements, allocatedStart, nitems);
+                } else {
+                    /* Wrapped */
+                    final int end = length - allocatedStart;
+                    System.arraycopy((Object[])elements, off, queuedElements, allocatedStart, end);
+                    System.arraycopy((Object[])elements, off + end, queuedElements, 0, nitems - end);
+                }
+
+                while ((int)AVAILABLE_TAIL_INDEX_HANDLE.getVolatile(this) != currentIndex) {
+                    ConcurrentUtil.pause();
+                }
+                AVAILABLE_TAIL_INDEX_HANDLE.setVolatile(this, allocatedEnd | length);
+                return length - remainingLength;
+            }
+
+            final int requiredLength = (length - remainingLength) + nitems; /* Exclusive end of queue once resized and copied */
+
+            if ((flags & NORESIZE_FLAG) != 0 || requiredLength >= maxLength) {
+                return -1; /* TODO */
+            }
+
+            /* Attempt to lock allocated_tail_index */
+            if (!ALLOCATED_TAIL_INDEX_HANDLE.compareAndSet(this, currentIndex, UINT_MAX)) {
+                ++failures;
+                continue;
+            }
+
+            /* Add 1 to ensure that the resized queue will not be full */
+            /* It is an error if this queue is full as distinction between a full queue and an empty one is not possible */
+            /* exclusive end == inclusive start for both cases */
+            final int expectedLength = IntegerUtil.roundCeilLog2(requiredLength + 1);
+            final Object[] newElements = new Object[expectedLength];
+            final Object[] currElements = this.elements;
+
+            /* Copy previous elements over */
+            /* Note that while new indices cannot be allocated, some writes to the queue may not be finished */
+            /* wait for previous writes to complete */
+
+            /* Use acquire to acquire with the writes to elements */
+            while ((int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this) != currentIndex) {
+                ConcurrentUtil.pause();
+            }
+
+            /* Copy the elements over */
+
+            /* allocatedStart at this point is now the exclusive end of the queue */
+
+            if (queueStart < allocatedStart) {
+                /* Sequential */
+                System.arraycopy(currElements, queueStart, newElements, 0, length - remainingLength);
+            } else {
+                /* Wrapped */
+                final int end = length - queueStart;
+                System.arraycopy(currElements, queueStart, newElements, 0, end);
+                System.arraycopy(currElements, 0, newElements, end, allocatedStart);
+            }
+
+            /* Copy our elements over */
+
+            System.arraycopy((Object[])elements, off, newElements, length - remainingLength, nitems);
+
+            /* Update head */
+
+            for (int headcurr = (int)HEAD_INDEX_HANDLE.getVolatile(this);;) {
+                if ((headcurr & READING_BIT) != 0) {
+                    Thread.yield();
+                    headcurr = (int)HEAD_INDEX_HANDLE.getAcquire(this);
+                    continue;
+                }
+                /* Create new head index */
+                /* Elements may have been read during resizing, so we need to re-adjust */
+
+                final int oldHead = queueStart;
+                final int updatedHead = headcurr ^ length;
+
+                final int newHead = queueLength(oldHead, updatedHead, lengthMask) | expectedLength;
+
+                Arrays.fill(newElements, 0, newHead, null); /* Remove read elements */
+
+                /* Try to lock head */
+
+                if (!HEAD_INDEX_HANDLE.compareAndSet(this, headcurr, UINT_MAX)) {
+                    ConcurrentUtil.pause();
+                    continue;
+                }
+
+                /* Head is locked */
+                /* Note that this is the only area where reads can block */
+                this.elements = newElements;
+                AVAILABLE_TAIL_INDEX_HANDLE.set(this, requiredLength | expectedLength);
+
+                ALLOCATED_TAIL_INDEX_HANDLE.setRelease(this, requiredLength | expectedLength);
+
+                HEAD_INDEX_HANDLE.setVolatile(this, newHead);
+                /* Unlocked head */
+
+                break;
+            }
+
+            return length - remainingLength;
+        }
+
+    }
+
+
+}
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
new file mode 100644
index 000000000..0a1019761
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
@@ -0,0 +1,654 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+
+import javax.annotation.Nonnull;
+import java.lang.invoke.VarHandle;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.IntFunction;
+import java.util.function.Predicate;
+
+/**
+ * MT-Safe linked first in first out ordered queue.
+ *
+ * This queue should out-perform {@link java.util.concurrent.ConcurrentLinkedQueue} in high-contention reads/writes, and is
+ * not any slower in lower contention reads/writes.
+ * <p>
+ * Note that this queue breaks the specification laid out by {@link Collection}, see {@link #preventAdds()}.
+ * </p>
+ * @param <E> Type of element in this queue.
+ */
+public class ConcurrentLinkedList<E> implements Queue<E> {
+
+    //@jdk.internal.vm.annotation.Contended
+    private volatile LinkedNode<E> head; /* Always non-null, high chance of being the actual head */
+
+    //@jdk.internal.vm.annotation.Contended
+    private volatile LinkedNode<E> tail; /* Always non-null, high chance of being the actual tail */
+
+    /* Note that it is possible to reach head from tail. */
+
+    /* IMPL NOTE: Leave hashCode and equals to their defaults */
+
+    private static final VarHandle HEAD_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentLinkedList.class, "head", LinkedNode.class);
+    private static final VarHandle TAIL_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentLinkedList.class, "tail", LinkedNode.class);
+
+    /**
+     * Constructs a {@code ConcurrentLinkedList} initially empty.
+     * <p>
+     * The returned object may not be published without synchronization.
+     * </p>
+     */
+    public ConcurrentLinkedList() {
+        final LinkedNode<E> value = new LinkedNode<>(null, null);
+        HEAD_HANDLE.set(this, value);
+        TAIL_HANDLE.set(this, value);
+    }
+
+    /**
+     * Constructs a {@code ConcurrentLinkedList} initially containing all elements in the specified {@code collection}.
+     * <p>
+     * The returned object may not be published without synchronization.
+     * </p>
+     * @param collection The specified collection.
+     * @throws NullPointerException If {@code collection} is {@code null} or contains {@code null} elements.
+     */
+    public ConcurrentLinkedList(final Collection<? extends E> collection) {
+        final Iterator<? extends E> elements = collection.iterator();
+        if (!elements.hasNext()) {
+            final LinkedNode<E> value = new LinkedNode<>(null, null);
+            HEAD_HANDLE.set(this, value);
+            TAIL_HANDLE.set(this, value);
+            return;
+        }
+
+        final LinkedNode<E> head = new LinkedNode<>(validateNotNull(elements.next()), null);
+        LinkedNode<E> tail = head;
+
+        while (elements.hasNext()) {
+            final LinkedNode<E> next = new LinkedNode<>(validateNotNull(elements.next()), null);
+            LinkedNode.NEXT_HANDLE.set(tail, next);
+            tail = next;
+        }
+
+        HEAD_HANDLE.set(this, head);
+        TAIL_HANDLE.set(this, tail);
+    }
+
+    private static <T> T validateNotNull(final T value) {
+        if (value == null) {
+            throw new NullPointerException();
+        }
+        return value;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E remove() throws NoSuchElementException {
+        final E ret = this.poll();
+        if (ret == null) {
+            throw new NoSuchElementException();
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean add(final E element) {
+        return this.offer(element);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E element() throws NoSuchElementException {
+        final E ret = this.peek();
+        if (ret == null) {
+            throw new NoSuchElementException();
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean offer(final E element) {
+        if (element == null) {
+            throw new NullPointerException();
+        }
+        final LinkedNode<E> node = new LinkedNode<>(element, null);
+        return this.appendList(node, node);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E peek() {
+        return this.getHead(false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E poll() {
+        return this.getHead(true);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void clear() {
+        //noinspection StatementWithEmptyBody
+        while (this.poll() != null);
+    }
+
+    /**
+     * Constant time clear operation for this queue. Note that it is possible that some threads reading the queue will not
+     * be updated to this operation. For example, iterators and remove variants will not be notified, and sometimes
+     * peek/poll will not be notified. If there are no concurrent accesses to this queue, then this method will have the
+     * same effect as {@link #clear()}.
+     * @return {@code true} if the queue was cleared, {@code false} otherwise.
+     */
+    public boolean fastClear() {
+        final LinkedNode<E> newHead = new LinkedNode<>(null, null);
+        if (!this.appendList(newHead, newHead)) {
+            return false;
+        }
+        HEAD_HANDLE.setVolatile(this, newHead);
+        return true;
+    }
+
+    /**
+     * Prevents elements from being added to this queue. Once this is called, any attempt to add to this queue will fail.
+     * @return {@code true} if the queue was modified to prevent additions, {@code false} if it already prevented additions.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     */
+    public boolean preventAdds() {
+        final LinkedNode<E> deadEnd = new LinkedNode<>(null, null);
+        LinkedNode.NEXT_HANDLE.set(deadEnd, deadEnd);
+        if (!this.appendList(deadEnd, deadEnd)) {
+            return false;
+        }
+        TAIL_HANDLE.setVolatile(this, deadEnd);
+        return true;
+    }
+
+    /**
+     * Allows elements to be added to this queue once again. Note that this function has undefined behaviour if
+     * {@link #preventAdds()} is not called beforehand.
+     * <p>
+     * This function is not MT-Safe.
+     * </p>
+     */
+    public void allowAdds() {
+        //noinspection unchecked
+        LinkedNode.NEXT_HANDLE.setVolatile(((LinkedNode<E>)TAIL_HANDLE.get(this)), null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean remove(final Object object) {
+        if (object == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                continue;
+            }
+            if ((element == object || element.equals(object))
+                    && LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) == element) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeIf(final Predicate<? super E> filter) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                continue;
+            }
+            //noinspection unchecked
+            ret |= filter.test((E) element) && LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) == element;
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeAll(@Nonnull final Collection<?> collection) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                continue;
+            }
+            ret |= collection.contains(element) && LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) == element;
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean retainAll(@Nonnull final Collection<?> collection) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                continue;
+            }
+            ret |= !collection.contains(element) && LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) == element;
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Nonnull
+    @Override
+    public Object[] toArray() {
+        final List<E> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                continue;
+            }
+            //noinspection unchecked
+            ret.add((E) element);
+        }
+
+        return ret.toArray();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Nonnull
+    @Override
+    public <T> T[] toArray(@Nonnull final T[] array) {
+        final List<T> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                continue;
+            }
+            //noinspection unchecked
+            ret.add((T) element);
+        }
+
+        return ret.toArray(array);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> T[] toArray(final IntFunction<T[]> generator) {
+        final List<T> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                continue;
+            }
+            //noinspection unchecked
+            ret.add((T) element);
+        }
+
+        return ret.toArray(generator);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        final StringBuilder builder = new StringBuilder();
+
+        builder.append("ConcurrentLinkedList: {elements: {");
+
+        int deadEntries = 0;
+        int totalEntries = 0;
+        int aliveEntries = 0;
+
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next, ++totalEntries) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                ++deadEntries;
+            } else {
+                ++aliveEntries;
+            }
+
+            if (totalEntries != 0) {
+                builder.append(", ");
+            }
+
+            builder.append(totalEntries).append(": \"").append(element).append('"');
+        }
+
+        builder.append("}, total_entries: \"").append(totalEntries).append("\", alive_entries: \"").append(aliveEntries)
+                .append("\", dead_entries:").append(deadEntries).append("\"}");
+
+        return builder.toString();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean addAll(@Nonnull final Collection<? extends E> collection) {
+        final Iterator<? extends E> elements = collection.iterator();
+        if (!elements.hasNext()) {
+            return false;
+        }
+
+        /* Build a list of nodes to append */
+        /* This is an order of magnitudes faster due to the fact that zero synchronization is performed */
+
+        final LinkedNode<E> head = new LinkedNode<>(validateNotNull(elements.next()), null);
+        LinkedNode<E> tail = head;
+
+        while (elements.hasNext()) {
+            final LinkedNode<E> next = new LinkedNode<>(validateNotNull(elements.next()), null);
+            LinkedNode.NEXT_HANDLE.set(tail, next);
+            tail = next;
+        }
+
+        return this.appendList(head, tail);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean containsAll(@Nonnull final Collection<?> collection) {
+        for (final Object element : collection) {
+            if (!this.contains(element)) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Nonnull
+    @Override
+    public Iterator<E> iterator() {
+        return new LinkedIterator<>(this.head);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Note that this function is computed non-atomically and in O(n) time. The value returned may not be representative of
+     * the queue in its current state.
+     * </p>
+     */
+    @Override
+    public int size() {
+        int size = 0;
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                continue;
+            }
+            ++size;
+        }
+        return size;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isEmpty() {
+        return this.peek() != null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean contains(final Object object) {
+        if (object == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == object || element.equals(object)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void forEach(final Consumer<? super E> action) {
+        if (action == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.head; curr != null; curr = curr.next) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                //noinspection unchecked
+                action.accept((E) element);
+            }
+        }
+    }
+
+    private boolean appendList(final LinkedNode<E> head, final LinkedNode<E> tail) {
+        /* assume tail.next is null */
+        int failures = 0;
+        for (LinkedNode<E> currTail = null, curr = null;;) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+            /* This allows a backoff to not become immediately out-of-date by allowing tail retrieval to happen after backoff */
+            if (currTail != (currTail = this.tail)) {
+                /* New tail */
+                curr = currTail;
+            }
+
+            /* this.tail cannot be null */
+
+            //noinspection ConstantConditions
+            final LinkedNode<E> next = curr.next;
+
+            if (next == curr) {
+                /* Queue additions are stopped */
+                return false;
+            }
+
+            if (next == null) {
+                /* End of queue */
+                //noinspection unchecked
+                final LinkedNode<E> updatedNext = (LinkedNode<E>) LinkedNode.NEXT_HANDLE.compareAndExchange(curr, null, head);
+
+                if (updatedNext != null) {
+                    /* Failure */
+                    ++failures;
+
+                    if (updatedNext == curr) {
+                        /* Queue additions are stopped */
+                        return false;
+                    }
+
+                    curr = updatedNext;
+                    continue;
+                }
+
+                /* Try to update tail */
+
+                /* Note that on x86 a compare and exchange has the same cost as a volatile write */
+
+                /* Only write to tail if we have the updated version */
+                /* This ensures that we don't set the tail to an outdated value */
+                /* This matters for high contention */
+
+                TAIL_HANDLE.compareAndExchange(this, currTail, tail);
+                return true;
+            } else {
+                /* Try to update to the latest tail if possible */
+
+                curr = next;
+            }
+        }
+    }
+
+    private E getHead(final boolean remove) {
+        int failures = 0;
+        for (LinkedNode<E> currHead = null, curr = null;;) {
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+
+            /* This allows a backoff to not become immediately out-of-date by allowing head/next retrieval to happen after backoff */
+            if (currHead != (currHead = this.head)) {
+                /* New head */
+                curr = currHead;
+            } else {
+                /* Try to advance curr */
+
+                curr = curr.next;
+                if (curr == null) {
+                    return null;
+                }
+            }
+
+            final Object currentValue = curr.element;
+            if (currentValue != null) {
+                if (!remove) {
+                    //noinspection unchecked
+                    return (E) currentValue;
+                }
+
+                if (LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) != currentValue) {
+                    /* Some other thread read this element */
+                    ++failures;
+
+                    continue;
+                }
+                /* Successfully read element */
+
+                /* Try to CAS head forward */
+                final LinkedNode<E> next = curr.next;
+                if (next != null) {
+                    HEAD_HANDLE.compareAndExchange(this, currHead, next);
+                }
+
+                //noinspection unchecked
+                return (E) currentValue;
+            }
+            /* This element is removed, try again */
+        }
+    }
+
+    private static final class LinkedNode<E> {
+
+        private volatile Object element;
+        private volatile LinkedNode<E> next;
+
+        private static final VarHandle ELEMENT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "element", Object.class);
+        private static final VarHandle NEXT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "next", LinkedNode.class);
+
+        LinkedNode(final Object element, final LinkedNode<E> next) {
+            ELEMENT_HANDLE.set(this, element);
+            NEXT_HANDLE.set(this, next);
+        }
+
+    }
+
+    private static final class LinkedIterator<E> implements Iterator<E> {
+
+        private LinkedNode<E> curr;
+        private E next;
+
+        LinkedIterator(final LinkedNode<E> head) {
+            this.curr = head;
+        }
+
+        /* sets next to the next value, or null if empty */
+        private void findNext() {
+            LinkedNode<E> curr = this.curr;
+            for (; curr != null; curr = curr.next) {
+                //noinspection unchecked
+                final E element = (E) LinkedNode.ELEMENT_HANDLE.getAcquire(curr);
+                if (element != null) {
+                    this.curr = curr;
+                    this.next = element;
+                    return;
+                }
+            }
+            /* reached end of list */
+            this.curr = null;
+            this.next = null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean hasNext() {
+            if (this.next == null) {
+                this.findNext();
+            }
+            return this.next == null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public E next() {
+            if (!this.hasNext()) {
+                throw new NoSuchElementException();
+            }
+            return this.next;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void remove() {
+            if (this.next == null) {
+                throw new IllegalStateException();
+            }
+            LinkedNode.ELEMENT_HANDLE.setVolatile(this.curr, null);
+            this.next = null;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
new file mode 100644
index 000000000..79615254d
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
@@ -0,0 +1,39 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+
+public final class ConcurrentUtil {
+
+    /**
+     * Closest possible implementation of the x86 PAUSE instruction.
+     */
+    public static void pause() {
+        Thread.onSpinWait();
+    }
+
+    public static VarHandle getVarHandle(final Class<?> lookIn, final String fieldName, final Class<?> fieldType) {
+        try {
+            return MethodHandles.privateLookupIn(lookIn, MethodHandles.lookup()).findVarHandle(lookIn, fieldName, fieldType);
+        } catch (final Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public static VarHandle getStaticVarHandle(final Class<?> lookIn, final String fieldName, final Class<?> fieldType) {
+        try {
+            return MethodHandles.privateLookupIn(lookIn, MethodHandles.lookup()).findStaticVarHandle(lookIn, fieldName, fieldType);
+        } catch (final Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public static VarHandle getArrayHandle(final Class<?> type) {
+        return MethodHandles.arrayElementVarHandle(type);
+    }
+
+    private ConcurrentUtil() {
+        throw new RuntimeException();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java b/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java
new file mode 100644
index 000000000..eedf0c9e2
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java
@@ -0,0 +1,31 @@
+package io.github.spottedleaf.concrete.util;
+
+public class IntegerUtil {
+
+    private static final int HIGH_BIT = Integer.MIN_VALUE;
+
+    public static int ceilLog2(final int value) {
+        return 32 - Integer.numberOfLeadingZeros(value - 1);
+    }
+
+    public static int floorLog2(final int value) {
+        return 31 ^ Integer.numberOfLeadingZeros(value);
+    }
+
+    public static int roundCeilLog2(final int value) {
+        return HIGH_BIT >>> (Integer.numberOfLeadingZeros(value) - 1);
+    }
+
+    public static int roundFloorLog2(final int value) {
+        return HIGH_BIT >>> Integer.numberOfLeadingZeros(value);
+    }
+
+    public static boolean isPowerOfTwo(final int n) {
+        return (-n & n) == n;
+    }
+
+    private IntegerUtil() {
+        throw new RuntimeException();
+    }
+
+}
-- 
2.20.1

