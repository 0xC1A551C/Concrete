From 367309865c7b987c721a717c88641b367c785532 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 18 Dec 2018 04:24:08 -0800
Subject: [PATCH] Multi-Threaded chunk ticking

---
 .../concrete/chunk/ChunkRegionManager.java    | 124 ++++++++++++++++++
 1 file changed, 124 insertions(+)
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java

diff --git a/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
new file mode 100644
index 000000000..194cce583
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
@@ -0,0 +1,124 @@
+package io.github.spottedleaf.concrete.chunk;
+
+import io.github.spottedleaf.concurrentutil.queue.ConcurrentLinkedList;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.server.Chunk;
+
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Consumer;
+
+public class ChunkRegionManager {
+
+    private final Long2ObjectOpenHashMap<ChunkRegion> regions = new Long2ObjectOpenHashMap<>(2048);
+
+    /**
+     * Adds a chunk to this region manager. If {@code synchronously} is {@code true}, then the chunk's region
+     * lock is acquired, the chunk is added, then the region's lock is released. Otherwise, the chunk add is performed
+     * via {@link ChunkRegion#executeNonUrgentTask(Consumer)}.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     * @param chunk The specified chunk to add.
+     * @param synchronously Whether to add the chunk synchronously.
+     */
+    public void addChunk(final Chunk chunk, final boolean synchronously) {
+
+    }
+
+    /**
+     * Adds a chunk to this region manager. This function assumes the caller already owns the region which the
+     * specified chunk resides in. If the caller does not own the region, undefined behaviour occurs.
+     * @param chunk The specified chunk.
+     */
+    public void addChunkRelaxed(final Chunk chunk) {
+
+    }
+
+    /**
+     * Removes the specified chunk from this region manager. This function presumes no chunks can be removed or
+     * added concurrently. That is, chunks are only removed by a single thread at the end of a tick.
+     * <p>
+     * This function is not MT-Safe.
+     * </p>
+     * @param chunk The specified chunk.
+     */
+    public void removeChunk(final Chunk chunk) {
+
+    }
+
+    public static class ChunkRegion {
+
+        public final ChunkRegionManager regionManager;
+
+        private final ReentrantLock lock = new ReentrantLock();
+
+        /**
+         * Tasks that need to be executed after releasing the region.
+         */
+        private final ConcurrentLinkedList<Consumer<ChunkRegion>> tasks = new ConcurrentLinkedList<>();
+
+        public ChunkRegion(final ChunkRegionManager regionManager) {
+            this.regionManager = regionManager;
+            this.tasks.preventAdds(); /* Required since an add-blocked queue represents a free region */
+        }
+
+        public void addChunk(final Chunk chunk) {
+
+        }
+
+        public void removeChunk(final Chunk chunk) {
+
+        }
+
+        public int chunkConut() {
+            return 0;
+        }
+
+        private void drainTasks() {
+            this.tasks.drain((final Consumer<ChunkRegion> consumer) -> {
+                consumer.accept(ChunkRegion.this);
+            },true);
+        }
+
+        public void releaseLock() {
+            if (this.lock.getHoldCount() == 1) {
+                /* This is required to prevent a race condition where a task is executed on a tick segment later than it is expected */
+                this.drainTasks();
+            }
+            this.lock.unlock();
+        }
+
+        public void acquireLock() {
+            this.lock.lock();
+            if (this.lock.getHoldCount() == 1) {
+                this.tasks.allowAdds();
+            }
+        }
+
+        public boolean tryAcquireLock() {
+            if (!this.lock.tryLock()) {
+                return false;
+            }
+            if (this.lock.getHoldCount() == 1) {
+                this.tasks.allowAdds();
+            }
+            return true;
+        }
+
+        public boolean executeNonUrgentTask(final Consumer<ChunkRegion> consumer) {
+            for (;;) {
+                /* Either successfully add to wait queue or lock the region */
+                /* Note that order here matters, threads already owning a region should execute its task synchronously! */
+                if (this.tryAcquireLock()) {
+                    consumer.accept(this);
+                    this.releaseLock();
+                    return true;
+                } else if (this.tasks.add(consumer)) {
+                    return false;
+                }
+                /* Failure means retry, one has to eventually work (and we only reach this point due to a rare race condition) */
+            }
+        }
+
+    }
+}
-- 
2.20.1

