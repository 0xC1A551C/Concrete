From bfea6a10f7c5bdee46e4c82fdcfce364a6ca27e2 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 18 Dec 2018 04:24:08 -0800
Subject: [PATCH] Multi-Threaded chunk ticking

---
 .../concrete/chunk/ChunkRegionManager.java    | 126 +++
 .../concurrent/ConcurrentArrayQueue.java      | 461 ++++++++++
 .../concurrent/ConcurrentLinkedList.java      | 846 ++++++++++++++++++
 .../concrete/concurrent/ConcurrentUtil.java   |  39 +
 .../concrete/util/IntegerUtil.java            |  52 ++
 5 files changed, 1524 insertions(+)
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java

diff --git a/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
new file mode 100644
index 000000000..5e0e2ea99
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
@@ -0,0 +1,126 @@
+package io.github.spottedleaf.concrete.chunk;
+
+import io.github.spottedleaf.concrete.concurrent.ConcurrentLinkedList;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.server.Chunk;
+
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Consumer;
+
+public class ChunkRegionManager {
+
+    private final Long2ObjectOpenHashMap<ChunkRegion> regions = new Long2ObjectOpenHashMap<>(2048);
+
+    /**
+     * Adds a chunk to this region manager. If {@code synchronously} is {@code true}, then the chunk's region
+     * lock is acquired, the chunk is added, then the region's lock is released. Otherwise, the chunk add is performed
+     * via {@link ChunkRegion#executeNonUrgentTask(Consumer)}.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     * @param chunk The specified chunk to add.
+     * @param synchronously Whether to add the chunk synchronously.
+     */
+    public void addChunk(final Chunk chunk, final boolean synchronously) {
+
+    }
+
+    /**
+     * Adds a chunk to this region manager. This function assumes the caller already owns the region which the
+     * specified chunk resides in. If the caller does not own the region, undefined behaviour occurs.
+     * @param chunk The specified chunk.
+     */
+    public void addChunkRelaxed(final Chunk chunk) {
+
+    }
+
+    /**
+     * Removes the specified chunk from this region manager. This function presumes no chunks can be removed or
+     * added concurrently. That is, chunks are only removed by a single thread at the end of a tick.
+     * <p>
+     * This function is not MT-Safe.
+     * </p>
+     * @param chunk The specified chunk.
+     */
+    public void removeChunk(final Chunk chunk) {
+
+    }
+
+    public static class ChunkRegion {
+
+        public final ChunkRegionManager regionManager;
+
+        private final ReentrantLock lock = new ReentrantLock();
+
+        /**
+         * Tasks that need to be executed after releasing the region.
+         */
+        private final ConcurrentLinkedList<Consumer<ChunkRegion>> tasks = new ConcurrentLinkedList<>();
+
+        public ChunkRegion(final ChunkRegionManager regionManager) {
+            this.regionManager = regionManager;
+            this.tasks.preventAdds(); /* Required since an add-blocked queue represents a free region */
+        }
+
+        public void addChunk(final Chunk chunk) {
+
+        }
+
+        public void removeChunk(final Chunk chunk) {
+
+        }
+
+        public int chunkConut() {
+
+        }
+
+        private void drainTasks() {
+            this.tasks.drain((final Consumer<ChunkRegion> consumer) -> {
+                consumer.accept(ChunkRegion.this);
+            },true, (final Exception ex) -> {
+                throw new RuntimeException(ex);
+            });
+        }
+
+        public void releaseLock() {
+            if (this.lock.getHoldCount() == 1) {
+                /* This is required to prevent a race condition where a task is executed on a tick segment later than it is expected */
+                this.drainTasks();
+            }
+            this.lock.unlock();
+        }
+
+        public void acquireLock() {
+            this.lock.lock();
+            if (this.lock.getHoldCount() == 1) {
+                this.tasks.allowAdds();
+            }
+        }
+
+        public boolean tryAcquireLock() {
+            if (!this.lock.tryLock()) {
+                return false;
+            }
+            if (this.lock.getHoldCount() == 1) {
+                this.tasks.allowAdds();
+            }
+            return true;
+        }
+
+        public boolean executeNonUrgentTask(final Consumer<ChunkRegion> consumer) {
+            for (;;) {
+                /* Either successfully add to wait queue or lock the region */
+                /* Note that order here matters, threads already owning a region should execute its task synchronously! */
+                if (this.tryAcquireLock()) {
+                    consumer.accept(this);
+                    this.releaseLock();
+                    return true;
+                } else if (this.tasks.add(consumer)) {
+                    return false;
+                }
+                /* Failure means retry, one has to eventually work (and we only reach this point due to a rare race condition) */
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
new file mode 100644
index 000000000..1f2ce7936
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
@@ -0,0 +1,461 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+import io.github.spottedleaf.concrete.util.IntegerUtil;
+
+import java.lang.invoke.VarHandle;
+import java.util.Arrays;
+
+public final class ConcurrentArrayQueue<E> {
+
+    public static final int NORESIZE_FLAG = (1 << 0);
+    public static final int PEEK_FLAG     = (1 << 1);
+
+    private static final int UINT_MAX = -1;
+    private static final int MAX_INDEX = UINT_MAX >>> 2; /* 1 bit for encoded length, 1 bit for resize flag */
+    private static final int MAX_LENGTH = MAX_INDEX + 1;
+    private static final int INDEX_LENGTH_MASK = MAX_INDEX | MAX_LENGTH;
+
+    private static final int READING_BIT = Integer.MIN_VALUE;
+
+    private Object[] elements; /* access synchronized through indices */
+
+    /* Separate the indices into different cache lines */
+    private final int[] indices = new int[4 * (256 / 4)];
+
+
+    /**
+     * The first element in this queue.
+     */
+    private static final int AVAILABLE_HEAD_INDEX_INDEX = 1 * (256 / 4);
+
+    /**
+     * The ready-to-read last element added to this queue.
+     */
+    private static final int AVAILABLE_TAIL_INDEX_INDEX = 2 * (256 / 4);
+
+    /**
+     * The last element index allocated for writing.
+     */
+    private static final int ALLOCATED_TAIL_INDEX_INDEX = 3 * (256 / 4);
+
+    private static final VarHandle INDICES_HANDLE = ConcurrentUtil.getArrayHandle(int[].class);
+
+    public ConcurrentArrayQueue() {
+        this(32);
+    }
+
+    public ConcurrentArrayQueue(int capacity) {
+        if (capacity < 0 || capacity > MAX_LENGTH) {
+            throw new IllegalArgumentException("Capacity " + capacity + " is out of bounds");
+        } else if (capacity <= 32) {
+            capacity = 32;
+        } else {
+            final int prevCapacity = capacity;
+            capacity = IntegerUtil.roundCeilLog2(capacity);
+            if (capacity > MAX_LENGTH) {
+                throw new IllegalArgumentException("Capacity " + prevCapacity + " is out of bounds");
+            }
+        }
+
+        this.elements = new Object[capacity];
+        INDICES_HANDLE.set(this.indices, AVAILABLE_HEAD_INDEX_INDEX, capacity);
+        INDICES_HANDLE.set(this.indices, AVAILABLE_TAIL_INDEX_INDEX, capacity);
+        INDICES_HANDLE.set(this.indices, ALLOCATED_TAIL_INDEX_INDEX, capacity);
+        /*HEAD_INDEX_HANDLE.set(this, capacity);
+        AVAILABLE_TAIL_INDEX_HANDLE.set(this, capacity);
+        ALLOCATED_TAIL_INDEX_HANDLE.set(this, capacity);*/
+    }
+
+    /* Inclusive head, Exclusive tail */
+    private static int queueLength(final int head, final int tail, final int lengthMask) {
+        return (tail - head) & lengthMask;
+    }
+
+    /* Inclusive head, Exclusive tail */
+    private static int getRemainingLength(final int head, final int tail, final int length) {
+        if (head <= tail) {
+            return length - (tail - head);
+        } else {
+            return (head - tail);
+        }
+    }
+
+    public int capacity() {
+        int failures = 0;
+        for (;;) {
+            //final int tail = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+            final int tail = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return IntegerUtil.roundFloorLog2(tail);
+        }
+    }
+
+    public int size() {
+        int failures = 0;
+        for (;;) {
+            /*int head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+            final int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);*/
+            int head = (int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+            final int tail = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_TAIL_INDEX_INDEX);
+
+            if (head == UINT_MAX) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            head &= INDEX_LENGTH_MASK;
+
+            final int lengthHead = IntegerUtil.roundFloorLog2(head);
+            final int lengthTail = IntegerUtil.roundFloorLog2(tail);
+
+            if (lengthHead != lengthTail) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return queueLength(head ^ lengthHead, tail ^ lengthTail, lengthHead - 1);
+        }
+    }
+
+    public int remainingCapacity() {
+        int failures = 0;
+        for (;;) {
+            /*int head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+            final int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);*/
+            int head = (int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+            final int tail = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_TAIL_INDEX_INDEX);
+
+            if (head == UINT_MAX) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            head &= INDEX_LENGTH_MASK;
+
+            final int lengthHead = IntegerUtil.roundFloorLog2(head);
+            final int lengthTail = IntegerUtil.roundFloorLog2(tail);
+
+            if (lengthHead != lengthTail) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return getRemainingLength(head ^ lengthHead, tail ^ lengthTail, lengthHead);
+        }
+    }
+
+    private int acquireHead(final int flags) {
+        int head;
+        if ((flags & NORESIZE_FLAG) != 0) {
+            //head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+            head = (int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+        } else {
+            for (int failures = 0;;++failures) {
+                //head = (int)HEAD_INDEX_HANDLE.getAndBitwiseOr(this, READING_BIT);
+                head = (int)INDICES_HANDLE.getAndBitwiseOr(this.indices, AVAILABLE_HEAD_INDEX_INDEX, READING_BIT);
+                if ((head & READING_BIT) == 0) {
+                    break;
+                }
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+            }
+        }
+        return head;
+    }
+
+    private void releaseHead(final int oldHead, final int newHead, final int length, final int flags) {
+        if ((flags & PEEK_FLAG) != 0) {
+            /* Only write when there is a need to */
+            if ((flags & NORESIZE_FLAG) == 0) {
+                //HEAD_INDEX_HANDLE.setVolatile(this, head | length);
+                INDICES_HANDLE.setVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX, oldHead | length);
+            }
+        } else {
+            //HEAD_INDEX_HANDLE.setVolatile(this, newHead | length);
+            INDICES_HANDLE.setVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX, newHead | length);
+        }
+    }
+
+    public int read(final E[] buffer, final int maxItems, final int flags) {
+        int head = this.acquireHead(flags);
+
+        /* Since writes to tail are seq_cst, and sychronization already occured, tail is pretty up-to-date */
+        /* Use acquire to synchronize with the state at tail's point in time */
+        //int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);
+        int tail = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_TAIL_INDEX_INDEX);
+
+        /* By locking the head it is guaranteed the tail will have the same length as head */
+        final Object[] elements = this.elements;
+
+        final int length = IntegerUtil.roundFloorLog2(head);
+        final int lengthMask = length - 1;
+
+        tail ^= length;
+        head ^= length;
+
+        int itemsToRead = queueLength(head, tail, lengthMask);
+
+        if (itemsToRead >= maxItems) {
+            itemsToRead = maxItems;
+        }
+
+        final int newHead = (head + itemsToRead) & lengthMask;
+
+        if (newHead >= head) {
+            /* Sequential */
+            if (buffer != null) {
+                System.arraycopy(elements, head, (Object[]) buffer, 0, itemsToRead);
+            }
+            if ((flags & PEEK_FLAG) == 0) {
+                Arrays.fill(elements, head, head + itemsToRead, null);
+            }
+        } else {
+            /* Wrapped */
+            final int end = length - head;
+            if ((flags & PEEK_FLAG) != 0) {
+                if (buffer != null) {
+                    System.arraycopy(elements, head, (Object[]) buffer, 0, end);
+                    System.arraycopy(elements, 0, (Object[]) buffer, end, itemsToRead - end);
+                }
+            } else {
+                if (buffer != null) {
+                    System.arraycopy(elements, head, (Object[]) buffer, 0, end);
+                }
+                Arrays.fill(elements, head, head + end, null);
+                if (buffer != null) {
+                    System.arraycopy(elements, 0, (Object[]) buffer, end, itemsToRead - end);
+                }
+                Arrays.fill(elements, 0, itemsToRead - end, null);
+            }
+        }
+
+        this.releaseHead(head, newHead, length, flags);
+
+        return itemsToRead;
+    }
+
+    @SafeVarargs
+    public final int add(final E... elements) {
+        return this.add(elements, 0, elements.length, 0);
+    }
+
+    public int add(final E[] elements, final int off, final int nitems, final int flags) {
+        final int maxLength = MAX_LENGTH;
+
+        if (nitems >= maxLength) {
+            throw new IllegalArgumentException("nitems is too large: " + nitems);
+        }
+
+        int currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+        int failures = 0;
+        for (;;) {
+            /* Exponential backoff */
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+            /* Retrieve current_index after backoff to ensure it's not immediately out-of-date */
+            /* Nevermind this drops perf by 4x */
+            //currentIndex = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+            //currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+
+            if (currentIndex == UINT_MAX) {
+                Thread.yield();
+                //currentIndex = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+                currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+            }
+
+            /* Not resizing */
+
+            /* Decode length */
+            final int length = IntegerUtil.roundFloorLog2(currentIndex);
+            final int lengthMask = length - 1;
+
+            final int allocatedStart = currentIndex ^ length; /* Inclusive */
+            final int allocatedEnd = (currentIndex + nitems) & lengthMask; /* Exclusive */
+
+            //final int currentHeadRaw = (int)HEAD_INDEX_HANDLE.getAcquire(this);
+            final int currentHeadRaw = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+
+            /* Validate the indices */
+
+            /*
+             * May not be resizing
+             * Must have equal encoded lengths (otherwise size check is invalid)
+             */
+
+            if (currentHeadRaw == UINT_MAX) {
+                ConcurrentUtil.pause();
+                currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+                continue;
+            }
+            if (IntegerUtil.roundFloorLog2(currentHeadRaw & INDEX_LENGTH_MASK) != length) {
+                ConcurrentUtil.pause();
+                currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+                continue;
+            }
+
+            /* Finished validating the head index */
+
+            final int queueStart = currentHeadRaw & lengthMask; /* Inclusive */
+
+            /* Find remaining length to ensure there is enough space */
+            final int remainingLength = getRemainingLength(queueStart, allocatedStart, length);
+
+            if (remainingLength > nitems) {
+                /* space available */
+                //if (!ALLOCATED_TAIL_INDEX_HANDLE.compareAndSet(this, currentIndex, allocatedEnd | length)) {
+                final int prevCurrIndex = currentIndex;
+                if ((currentIndex = (int)INDICES_HANDLE.compareAndExchange(this.indices, ALLOCATED_TAIL_INDEX_INDEX, currentIndex, allocatedEnd | length)) != prevCurrIndex) {
+                    ConcurrentUtil.pause();
+                    ++failures;
+                    continue;
+                }
+
+                final Object[] queuedElements = this.elements;
+                if (allocatedEnd >= allocatedStart) {
+                    /* Sequential */
+                    System.arraycopy((Object[])elements, off, queuedElements, allocatedStart, nitems);
+                } else {
+                    /* Wrapped */
+                    final int end = length - allocatedStart;
+                    System.arraycopy((Object[])elements, off, queuedElements, allocatedStart, end);
+                    System.arraycopy((Object[])elements, off + end, queuedElements, 0, nitems - end);
+                }
+
+                while ((int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_TAIL_INDEX_INDEX) != currentIndex) {
+                    ConcurrentUtil.pause();
+                }
+                //AVAILABLE_TAIL_INDEX_HANDLE.setVolatile(this, allocatedEnd | length);
+                INDICES_HANDLE.setVolatile(this.indices, AVAILABLE_TAIL_INDEX_INDEX, allocatedEnd | length);
+                return length - remainingLength;
+            }
+
+            final int requiredLength = (length - remainingLength) + nitems; /* Exclusive end of queue once resized and copied */
+
+            if ((flags & NORESIZE_FLAG) != 0 || requiredLength >= maxLength) {
+                return -1; /* TODO */
+            }
+
+            /* Attempt to lock allocated_tail_index */
+            //if (!ALLOCATED_TAIL_INDEX_HANDLE.compareAndSet(this, currentIndex, UINT_MAX)) {
+            if (!INDICES_HANDLE.compareAndSet(this.indices, ALLOCATED_TAIL_INDEX_INDEX, currentIndex, UINT_MAX)) {
+                ++failures;
+                continue;
+            }
+
+            /* Add 1 to ensure that the resized queue will not be full */
+            /* It is an error if this queue is full as distinction between a full queue and an empty one is not possible */
+            /* exclusive end == inclusive start for both cases */
+            final int expectedLength = IntegerUtil.roundCeilLog2(requiredLength + 1);
+            final Object[] newElements = new Object[expectedLength];
+            final Object[] currElements = this.elements;
+
+            /* Copy previous elements over */
+            /* Note that while new indices cannot be allocated, some writes to the queue may not be finished */
+            /* wait for previous writes to complete */
+
+            /* Use acquire to acquire with the writes to elements (thus synchronizing with other writers) */
+            //while ((int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this) != currentIndex) {
+            int spinWaitFailures = 0;
+            while ((int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_TAIL_INDEX_INDEX) != currentIndex) {
+                if (spinWaitFailures == 1000) {
+                    spinWaitFailures = 0;
+                    Thread.yield();
+                    /* This will not fix the thread scheduling issues however it should prevent total loss of performance */
+                }
+                ConcurrentUtil.pause();
+                ++spinWaitFailures;
+            }
+
+            /* Copy the elements over */
+
+            /* allocatedStart at this point is now the exclusive end of the queue */
+
+            if (queueStart < allocatedStart) {
+                /* Sequential */
+                System.arraycopy(currElements, queueStart, newElements, 0, length - remainingLength);
+            } else {
+                /* Wrapped */
+                final int end = length - queueStart;
+                System.arraycopy(currElements, queueStart, newElements, 0, end);
+                System.arraycopy(currElements, 0, newElements, end, allocatedStart);
+            }
+
+            /* Copy our elements over */
+
+            System.arraycopy((Object[])elements, off, newElements, length - remainingLength, nitems);
+
+            /* Update head */
+
+            //for (int headcurr = (int)HEAD_INDEX_HANDLE.getVolatile(this);;) {
+            for (int headcurr = (int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX);;) {
+                if ((headcurr & READING_BIT) != 0) {
+                    Thread.yield();
+                    headcurr = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+                    continue;
+                }
+                /* Create new head index */
+                /* Elements may have been read during resizing, so we need to re-adjust */
+
+                final int oldHead = queueStart;
+                final int updatedHead = headcurr ^ length;
+
+                final int newHead = queueLength(oldHead, updatedHead, lengthMask) | expectedLength;
+
+                Arrays.fill(newElements, 0, newHead, null); /* Remove read elements */
+
+                /* Try to lock head */
+
+                //if (!HEAD_INDEX_HANDLE.compareAndSet(this, headcurr, UINT_MAX)) {
+                if (!INDICES_HANDLE.compareAndSet(this.indices, AVAILABLE_HEAD_INDEX_INDEX, headcurr, UINT_MAX)) {
+                    ConcurrentUtil.pause();
+                    continue;
+                }
+
+                /* Head is locked */
+                /* Note that this is the only area where reads can block */
+                this.elements = newElements;
+                //AVAILABLE_TAIL_INDEX_HANDLE.set(this, requiredLength | expectedLength);
+                INDICES_HANDLE.set(this.indices, AVAILABLE_TAIL_INDEX_INDEX, remainingLength | expectedLength);
+
+                //ALLOCATED_TAIL_INDEX_HANDLE.setRelease(this, requiredLength | expectedLength);
+                INDICES_HANDLE.setRelease(this.indices, requiredLength | expectedLength);
+
+                //HEAD_INDEX_HANDLE.setVolatile(this, newHead);
+                INDICES_HANDLE.setVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX, newHead);
+                /* Unlocked head */
+
+                break;
+            }
+            return length - remainingLength;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
new file mode 100644
index 000000000..cb5df1fcb
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
@@ -0,0 +1,846 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+import java.lang.invoke.VarHandle;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.IntFunction;
+import java.util.function.Predicate;
+
+/**
+ * MT-Safe linked first in first out ordered queue.
+ *
+ * This queue should out-perform {@link java.util.concurrent.ConcurrentLinkedQueue} in high-contention reads/writes, and is
+ * not any slower in lower contention reads/writes.
+ * <p>
+ * Note that this queue breaks the specification laid out by {@link Collection}, see {@link #preventAdds()} and {@link Collection#add(Object)}.
+ * </p>
+ * @param <E> Type of element in this queue.
+ */
+public class ConcurrentLinkedList<E> implements Queue<E> {
+
+    //@jdk.internal.vm.annotation.Contended
+    private volatile LinkedNode<E> head; /* Always non-null, high chance of being the actual head */
+
+    //@jdk.internal.vm.annotation.Contended
+    private volatile LinkedNode<E> tail; /* Always non-null, high chance of being the actual tail */
+
+    /* Note that it is possible to reach head from tail. */
+
+    /* IMPL NOTE: Leave hashCode and equals to their defaults */
+
+    private static final VarHandle HEAD_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentLinkedList.class, "head", LinkedNode.class);
+    private static final VarHandle TAIL_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentLinkedList.class, "tail", LinkedNode.class);
+
+    private void setHeadPlain(final LinkedNode<E> newHead) {
+        HEAD_HANDLE.set(this, newHead);
+    }
+
+    private void setTailPlain(final LinkedNode<E> newTail) {
+        TAIL_HANDLE.set(this, newTail);
+    }
+
+    private void setHeadOpaque(final LinkedNode<E> newHead) {
+        HEAD_HANDLE.setOpaque(this, newHead);
+    }
+
+    private void setTailOpaque(final LinkedNode<E> newTail) {
+        TAIL_HANDLE.setOpaque(this, newTail);
+    }
+
+    @SuppressWarnings("unchecked")
+    private LinkedNode<E> getHeadOpaque() {
+        return (LinkedNode<E>)HEAD_HANDLE.getOpaque(this);
+    }
+
+    @SuppressWarnings("unchecked")
+    private LinkedNode<E> getTailOpaque() {
+        return (LinkedNode<E>)TAIL_HANDLE.getOpaque(this);
+    }
+
+    /**
+     * Constructs a {@code ConcurrentLinkedList}, initially empty.
+     * <p>
+     * The returned object may not be published without synchronization.
+     * </p>
+     */
+    public ConcurrentLinkedList() {
+        final LinkedNode<E> value = new LinkedNode<>(null, null);
+        this.setHeadPlain(value);
+        this.setTailPlain(value);
+    }
+
+    /**
+     * Constructs a {@code ConcurrentLinkedList}, initially containing all elements in the specified {@code collection}.
+     * <p>
+     * The returned object may not be published without synchronization.
+     * </p>
+     * @param collection The specified collection.
+     * @throws NullPointerException If {@code collection} is {@code null} or contains {@code null} elements.
+     */
+    public ConcurrentLinkedList(final Collection<? extends E> collection) {
+        final Iterator<? extends E> elements = collection.iterator();
+        if (!elements.hasNext()) {
+            final LinkedNode<E> value = new LinkedNode<>(null, null);
+            this.setHeadPlain(value);
+            this.setTailPlain(value);
+            return;
+        }
+
+        final LinkedNode<E> head = new LinkedNode<>(validateNotNull(elements.next()), null);
+        LinkedNode<E> tail = head;
+
+        while (elements.hasNext()) {
+            final LinkedNode<E> next = new LinkedNode<>(validateNotNull(elements.next()), null);
+            tail.setNextPlain(next);
+            tail = next;
+        }
+
+        this.setHeadPlain(head);
+        this.setTailPlain(tail);
+    }
+
+    private static <T> T validateNotNull(final T value) {
+        if (value == null) {
+            throw new NullPointerException();
+        }
+        return value;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E remove() throws NoSuchElementException {
+        final E ret = this.poll();
+        if (ret == null) {
+            throw new NoSuchElementException();
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean add(final E element) {
+        return this.offer(element);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E element() throws NoSuchElementException {
+        final E ret = this.peek();
+        if (ret == null) {
+            throw new NoSuchElementException();
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean offer(final E element) {
+        final LinkedNode<E> node = new LinkedNode<>(validateNotNull(element), null);
+        return this.appendList(node, node);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E peek() {
+        return this.getHead(false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E poll() {
+        return this.getHead(true);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void clear() {
+        //noinspection StatementWithEmptyBody
+        while (this.poll() != null);
+    }
+
+    /**
+     * Prevents elements from being added to this queue. Once this is called, any attempt to add to this queue will fail.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     * @return {@code true} if the queue was modified to prevent additions, {@code false} if it already prevented additions.
+     */
+    public boolean preventAdds() {
+        final LinkedNode<E> deadEnd = new LinkedNode<>(null, null);
+        deadEnd.setNextPlain(deadEnd);
+        if (!this.appendList(deadEnd, deadEnd)) {
+            return false;
+        }
+        this.setTailPlain(deadEnd); /* Ensure tail is set for the following #allowAdds call */
+        return true;
+    }
+
+    /**
+     * Allows elements to be added to this queue once again. Note that this function has undefined behaviour if
+     * {@link #preventAdds()} is not called beforehand.
+     * <p>
+     * This function is not MT-Safe.
+     * </p>
+     */
+    public void allowAdds() {
+        LinkedNode<E> tail = this.getTailOpaque();
+        /* We need to find the tail given the cas on tail isn't atomic (nor volatile) in this.appendList */
+        /* Thus it is possible for an outdated tail to be set */
+        while (tail != (tail = tail.getNextPlain())) {}
+        tail.setNextVolatile(null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean remove(final Object object) {
+        if (object == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                if ((element == object || element.equals(object))
+                        && curr.getAndSetElementVolatile(null) == element) {
+                    return true;
+                }
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeIf(final Predicate<? super E> filter) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                ret |= filter.test(element) && curr.getAndSetElementVolatile(null) == element;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeAll(final Collection<?> collection) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                ret |= collection.contains(element) && curr.getAndSetElementVolatile(null) == element;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean retainAll(final Collection<?> collection) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                ret |= !collection.contains(element) && curr.getAndSetElementVolatile(null) == element;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Object[] toArray() {
+        final List<E> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                ret.add(element);
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret.toArray();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> T[] toArray(final T[] array) {
+        final List<T> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                //noinspection unchecked
+                ret.add((T) element);
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret.toArray(array);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> T[] toArray(final IntFunction<T[]> generator) {
+        final List<T> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                //noinspection unchecked
+                ret.add((T) element);
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        return ret.toArray(generator);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        final StringBuilder builder = new StringBuilder();
+
+        builder.append("ConcurrentLinkedList: {elements: {");
+
+        int deadEntries = 0;
+        int totalEntries = 0;
+        int aliveEntries = 0;
+
+        for (LinkedNode<E> curr = this.getHeadOpaque();; ++totalEntries) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element == null) {
+                ++deadEntries;
+            } else {
+                ++aliveEntries;
+            }
+
+            if (totalEntries != 0) {
+                builder.append(", ");
+            }
+
+            builder.append(totalEntries).append(": \"").append(element).append('"');
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+
+        builder.append("}, total_entries: \"").append(totalEntries).append("\", alive_entries: \"").append(aliveEntries)
+                .append("\", dead_entries:").append(deadEntries).append("\"}");
+
+        return builder.toString();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean addAll(final Collection<? extends E> collection) {
+        final Iterator<? extends E> elements = collection.iterator();
+        if (!elements.hasNext()) {
+            return false;
+        }
+
+        /* Build a list of nodes to append */
+        /* This is an much faster due to the fact that zero additional synchronization is performed */
+
+        final LinkedNode<E> head = new LinkedNode<>(validateNotNull(elements.next()), null);
+        LinkedNode<E> tail = head;
+
+        while (elements.hasNext()) {
+            final LinkedNode<E> next = new LinkedNode<>(validateNotNull(elements.next()), null);
+            tail.setNextPlain(next);
+            tail = next;
+        }
+
+        return this.appendList(head, tail);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean containsAll(final Collection<?> collection) {
+        for (final Object element : collection) {
+            if (!this.contains(element)) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new LinkedIterator<>(this.getHeadOpaque());
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Note that this function is computed non-atomically and in O(n) time. The value returned may not be representative of
+     * the queue in its current state.
+     * </p>
+     */
+    @Override
+    public int size() {
+        int size = 0;
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                ++size;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+        return size;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isEmpty() {
+        return this.peek() != null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean contains(final Object object) {
+        if (object == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null && (element == object || element.equals(object))) {
+                return true;
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void forEach(final Consumer<? super E> action) {
+        if (action == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.getHeadOpaque();;) {
+            final E element = curr.getElementPlain(); /* Likely in sync */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            if (element != null) {
+                action.accept(element);
+            }
+
+            if (next == null || next == curr) {
+                break;
+            }
+            curr = next;
+        }
+    }
+
+    private boolean appendList(final LinkedNode<E> head, final LinkedNode<E> tail) {
+        int failures = 0;
+        for (LinkedNode<E> currTail = this.getTailOpaque(), curr = currTail;;) {
+            /* It has been experimentally shown that placing the read before the backoff results in significantly greater performance */
+            /* It is likely due to false sharing */
+            final LinkedNode<E> next = curr.getNextVolatile();
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+            if (next == null) {
+                final LinkedNode<E> compared = curr.compreExchangeNextVolatile(null, head);
+
+                if (compared == null) {
+                    /* Added */
+                    /* Avoid CASing on tail more than we need to */
+                    /* CAS to avoid setting an out-of-date tail */
+                    if (this.getTailOpaque() == currTail) {
+                        this.setTailOpaque(tail);
+                    }
+                    return true;
+                }
+
+                ++failures;
+                curr = compared;
+                continue;
+            } else if (next == curr) {
+                /* Additions are stopped */
+                return false;
+            }
+
+            if (curr == currTail) {
+                /* Tail is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to tail */
+                if (currTail == (currTail = this.getTailOpaque())) {
+                    curr = next;
+                } else {
+                    curr = currTail;
+                }
+            }
+        }
+    }
+
+    private E getHead(final boolean remove) {
+        int failures = 0;
+        for (LinkedNode<E> head = this.getHeadOpaque(), curr = head;;) {
+            final E currentVal = curr.getElementVolatile();
+            LinkedNode<E> next = null;
+            if (currentVal == null) {
+                next = curr.getNextPlain();
+            }
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+
+            if (currentVal != null) {
+                if (!remove) {
+                    return currentVal;
+                }
+                if (curr.compareExchangeElementVolatile(currentVal, null) != currentVal) {
+                    /* Failed to get head */
+                    next = curr.getNextPlain();
+                    if (curr == (curr = next)) {
+                        return null;
+                    }
+                    ++failures;
+                    continue;
+                }
+
+                if (curr != head) {
+                    next = curr.getNextPlain();
+                    /* Avoid CASing on head more than we need to */
+                    /* CAS to avoid setting an out-of-date head */
+                    if (this.getHeadOpaque() == head) {
+                        this.setHeadOpaque(next != null ? next : curr);
+                    }
+                }
+                return currentVal;
+            }
+
+            if (next == null) {
+                return null; /* End of queue */
+            }
+
+            if (head == curr) {
+                /* head is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to head */
+                if (head == (head = this.getHeadOpaque())) {
+                    curr = next;
+                } else {
+                    curr = head;
+                }
+            }
+        }
+    }
+
+    /**
+     * Empties the queue into the specified consumer. This function is optimized for single-threaded reads, and should
+     * be faster than a loop on {@link #poll()}.
+     * <p>
+     * This function is not MT-Safe. This function cannot be called with other read operations ({@link #peek()}, {@link #poll()},
+     * {@link #clear()}, etc).
+     * Write operations are safe to be called concurrently.
+     * </p>
+     * @param consumer The consumer to accept the elements.
+     * @return The total number of elements drained.
+     */
+    public int drain(final Consumer<E> consumer) {
+        return this.drain(consumer, false, (final Exception ex) -> {
+            throw new RuntimeException(ex);
+        });
+    }
+
+    /**
+     * Empties the queue into the specified consumer. This function is optimized for single-threaded reads, and should
+     * be faster than a loop on {@link #poll()}.
+     * <p>
+     * If {@code preventAdds} is {@code true}, then after this function returns the queue is guaranteed to be empty and
+     * additions to the queue will fail.
+     * </p>
+     * <p>
+     * This function is not MT-Safe. This function cannot be called with other read operations ({@link #peek()}, {@link #poll()},
+     * {@link #clear()}, {@link #remove(Object)} etc).
+     * Only write operations are safe to be called concurrently.
+     * </p>
+     * @param consumer The consumer to accept the elements.
+     * @param preventAdds Whether to prevent additions to this queue after draining.
+     * @param exceptionHandler Invoked when the consumer raises an exception.
+     * @return The total number of elements drained.
+     */
+    public int drain(final Consumer<E> consumer, final boolean preventAdds, final Consumer<Exception> exceptionHandler) {
+        /* This function assumes proper synchronization is made to ensure drain and no other read function are called concurrently */
+        /* This allows plain write usages instead of opaque or higher */
+        int total = 0;
+        final LinkedNode<E> head;
+        LinkedNode<E> curr = head = this.getHeadOpaque();
+        for (;;) {
+            final E currentVal = curr.getElementPlain();
+
+            /* Make sure to acquire with the write to the element field */
+            LinkedNode<E> next = curr.getNextAcquire();
+            if (next == curr) {
+                break;
+            }
+            if (currentVal == null) {
+                curr = next;
+                continue;
+            }
+
+            curr.setElementPlain(null);
+            ++total;
+
+            try {
+                consumer.accept(currentVal);
+            } catch (final Exception ex) {
+                this.setHeadPlain(next != null ? next : curr); /* Avoid perf penalty if the exception handler decides to re-throw */
+                exceptionHandler.accept(ex);
+            }
+
+            if (next == null) {
+                if (preventAdds) {
+                    if ((next = curr.compreExchangeNextVolatile(null, curr)) != null) {
+                        /* Retry with next value */
+                        curr = next;
+                        continue;
+                    }
+                }
+                break;
+            }
+            curr = next;
+        }
+        if (curr != head) {
+            this.setHeadOpaque(curr);
+        }
+        return total;
+    }
+
+    private static final class LinkedNode<E> {
+
+        private volatile Object element;
+        private volatile LinkedNode<E> next;
+
+        private static final VarHandle ELEMENT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "element", Object.class);
+        private static final VarHandle NEXT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "next", LinkedNode.class);
+
+        LinkedNode(final Object element, final LinkedNode<E> next) {
+            ELEMENT_HANDLE.set(this, element);
+            NEXT_HANDLE.set(this, next);
+        }
+
+        public void setElementPlain(final E update) {
+            ELEMENT_HANDLE.set(this, (Object)update);
+        }
+
+        public void setElementOpaque(final E update) {
+            ELEMENT_HANDLE.setOpaque(this, (Object)update);
+        }
+
+        @SuppressWarnings("unchecked")
+        public E getElementPlain() {
+            return (E)ELEMENT_HANDLE.get(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        public E getElementVolatile() {
+            return (E)ELEMENT_HANDLE.getVolatile(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        public E compareExchangeElementVolatile(final E expect, final E update) {
+            return (E)ELEMENT_HANDLE.compareAndExchange(this, expect, update);
+        }
+
+        @SuppressWarnings("unchecked")
+        public E getAndSetElementVolatile(final E update) {
+            return (E)ELEMENT_HANDLE.getAndSet(this, update);
+        }
+
+        public void setNextPlain(final LinkedNode<E> next) {
+            NEXT_HANDLE.set(this, next);
+        }
+
+        public void setNextVolatile(final LinkedNode<E> next) {
+            NEXT_HANDLE.setVolatile(this, next);
+        }
+
+        @SuppressWarnings("unchecked")
+        public LinkedNode<E> compreExchangeNextVolatile(final LinkedNode<E> expect, final LinkedNode<E> set) {
+            return (LinkedNode<E>)NEXT_HANDLE.compareAndExchange(this, expect, set);
+        }
+
+        @SuppressWarnings("unchecked")
+        public LinkedNode<E> getNextPlain() {
+            return (LinkedNode<E>)NEXT_HANDLE.get(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        public LinkedNode<E> getNextAcquire() {
+            return (LinkedNode<E>)NEXT_HANDLE.getAcquire(this);
+        }
+
+        @SuppressWarnings("unchecked")
+        public LinkedNode<E> getNextVolatile() {
+            return (LinkedNode<E>)NEXT_HANDLE.getVolatile(this);
+        }
+    }
+
+    private static final class LinkedIterator<E> implements Iterator<E> {
+
+        private LinkedNode<E> curr;
+        private E next;
+
+        LinkedIterator(final LinkedNode<E> head) {
+            this.curr = head;
+        }
+
+        /* sets next to the next value, or null if empty */
+        private void findNext() {
+            LinkedNode<E> curr = this.curr;
+            for (;curr != null;) {
+                final E element = (E) curr.getElementPlain();
+                final LinkedNode<E> next = curr.getNextVolatile();
+                if (element != null) {
+                    this.curr = curr;
+                    this.next = element;
+                    return;
+                }
+                if (next == curr) {
+                    break;
+                }
+                curr = next;
+            }
+            /* reached end of list */
+            this.curr = null;
+            this.next = null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean hasNext() {
+            if (this.next == null) {
+                this.findNext();
+            }
+            return this.next == null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public E next() {
+            if (!this.hasNext()) {
+                throw new NoSuchElementException();
+            }
+            return this.next;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void remove() {
+            if (this.next == null) {
+                throw new IllegalStateException();
+            }
+            this.curr.setElementOpaque(null);
+            this.next = null;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
new file mode 100644
index 000000000..79615254d
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
@@ -0,0 +1,39 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+
+public final class ConcurrentUtil {
+
+    /**
+     * Closest possible implementation of the x86 PAUSE instruction.
+     */
+    public static void pause() {
+        Thread.onSpinWait();
+    }
+
+    public static VarHandle getVarHandle(final Class<?> lookIn, final String fieldName, final Class<?> fieldType) {
+        try {
+            return MethodHandles.privateLookupIn(lookIn, MethodHandles.lookup()).findVarHandle(lookIn, fieldName, fieldType);
+        } catch (final Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public static VarHandle getStaticVarHandle(final Class<?> lookIn, final String fieldName, final Class<?> fieldType) {
+        try {
+            return MethodHandles.privateLookupIn(lookIn, MethodHandles.lookup()).findStaticVarHandle(lookIn, fieldName, fieldType);
+        } catch (final Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public static VarHandle getArrayHandle(final Class<?> type) {
+        return MethodHandles.arrayElementVarHandle(type);
+    }
+
+    private ConcurrentUtil() {
+        throw new RuntimeException();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java b/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java
new file mode 100644
index 000000000..81f974cb2
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java
@@ -0,0 +1,52 @@
+package io.github.spottedleaf.concrete.util;
+
+public class IntegerUtil {
+
+    public static final int HIGH_BIT_U32 = Integer.MIN_VALUE;
+    public static final long HIGH_BIT_U64 = Long.MIN_VALUE;
+
+    public static int ceilLog2(final int value) {
+        return 32 - Integer.numberOfLeadingZeros(value - 1);
+    }
+
+    public static long ceilLog2(final long value) {
+        return 64 - Long.numberOfLeadingZeros(value - 1);
+    }
+
+    public static int floorLog2(final int value) {
+        return 31 ^ Integer.numberOfLeadingZeros(value);
+    }
+
+    public static int floorLog2(final long value) {
+        return 63 ^ Long.numberOfLeadingZeros(value);
+    }
+
+    public static int roundCeilLog2(final int value) {
+        return HIGH_BIT_U32 >>> (Integer.numberOfLeadingZeros(value - 1) - 1);
+    }
+
+    public static long roundCeilLog2(final long value) {
+        return HIGH_BIT_U64 >>> (Long.numberOfLeadingZeros(value - 1) - 1);
+    }
+
+    public static int roundFloorLog2(final int value) {
+        return HIGH_BIT_U32 >>> Integer.numberOfLeadingZeros(value);
+    }
+
+    public static long roundFloorLog2(final long value) {
+        return HIGH_BIT_U64 >>> Long.numberOfLeadingZeros(value);
+    }
+
+    public static boolean isPowerOfTwo(final int n) {
+        return (-n & n) == n;
+    }
+
+    public static boolean isPowerOfTwo(final long n) {
+        return (-n & n) == n;
+    }
+
+    private IntegerUtil() {
+        throw new RuntimeException();
+    }
+
+}
-- 
2.20.1

