From a5800d2b670d5713c1a95754a9fbdfd47fd82e34 Mon Sep 17 00:00:00 2001
From: Spottedleaf <Spottedleaf@users.noreply.github.com>
Date: Tue, 18 Dec 2018 04:24:08 -0800
Subject: [PATCH] Multi-Threaded chunk ticking

---
 .../concrete/chunk/ChunkRegionManager.java    | 186 +++++
 .../concurrent/ConcurrentArrayQueue.java      | 461 +++++++++++
 .../concurrent/ConcurrentLinkedList.java      | 734 ++++++++++++++++++
 .../concrete/concurrent/ConcurrentUtil.java   |  39 +
 .../concrete/util/IntegerUtil.java            |  52 ++
 .../concrete/util/RegionChunkList.java        |  86 ++
 6 files changed, 1558 insertions(+)
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java
 create mode 100644 src/main/java/io/github/spottedleaf/concrete/util/RegionChunkList.java

diff --git a/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
new file mode 100644
index 000000000..f333766da
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/chunk/ChunkRegionManager.java
@@ -0,0 +1,186 @@
+package io.github.spottedleaf.concrete.chunk;
+
+import io.github.spottedleaf.concrete.concurrent.ConcurrentLinkedList;
+import io.github.spottedleaf.concrete.util.RegionChunkList;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import net.minecraft.server.Chunk;
+
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.function.Consumer;
+
+public class ChunkRegionManager {
+
+    public static final int REGION_WIDTH = 16; /* must be a power of two */
+
+    private final Long2ObjectOpenHashMap<ChunkRegion> regions = new Long2ObjectOpenHashMap<>(2048);
+
+    public static long getRegionKey(final int regionX, final int regionZ) {
+        return (long)(regionX) | ((long)regionZ << 32);
+    }
+
+    public static int getRegionX(final long key) {
+        return (int)key;
+    }
+
+    public static int getRegionZ(final long key) {
+        return (int)(key >>> 32);
+    }
+
+    public static int getRegionCoordinate(final int chunkCoord) {
+        return chunkCoord >> 4;
+    }
+
+    /**
+     * Adds a chunk to this region manager. If {@code synchronously} is {@code true}, then the chunk's region
+     * lock is acquired, the chunk is added, then the region's lock is released. Otherwise, the chunk add is performed
+     * via {@link ChunkRegion#executeNonUrgentTask(Consumer)}.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     * @param chunk The specified chunk to add.
+     * @param synchronously Whether to add the chunk synchronously.
+     */
+    public void addChunk(final Chunk chunk, final boolean synchronously) {
+        final int regionX = ChunkRegionManager.getRegionCoordinate(chunk.locX);
+        final int regionZ = ChunkRegionManager.getRegionCoordinate(chunk.locZ);
+        final long regionKey = ChunkRegionManager.getRegionKey(regionX, regionZ);
+
+        final ChunkRegion region;
+        synchronized (this.regions) {
+            region = this.regions.computeIfAbsent(regionKey, (final long key) -> {
+                return new ChunkRegion(ChunkRegionManager.this, regionX, regionZ, key);
+            });
+        }
+        if (synchronously) {
+            region.acquireLock();
+            region.addChunk(chunk);
+            region.releaseLock();
+        } else {
+            region.executeNonUrgentTask((final ChunkRegion r) -> r.addChunk(chunk));
+        }
+    }
+
+    /**
+     * Adds a chunk to this region manager. This function assumes the caller already owns the region which the
+     * specified chunk resides in. If the caller does not own the region, undefined behaviour occurs.
+     * @param chunk The specified chunk.
+     */
+    public void addChunkRelaxed(final Chunk chunk) {
+        final int regionX = ChunkRegionManager.getRegionCoordinate(chunk.locX);
+        final int regionZ = ChunkRegionManager.getRegionCoordinate(chunk.locZ);
+        final long regionKey = ChunkRegionManager.getRegionKey(regionX, regionZ);
+
+        final ChunkRegion region;
+        synchronized (this.regions) {
+            region = this.regions.get(regionKey);
+        }
+        region.addChunk(chunk);
+    }
+
+    /**
+     * Removes the specified chunk from this region manager. This function presumes no chunks can be removed or
+     * added concurrently. That is, chunks are only removed by a single thread at the end of a tick.
+     * <p>
+     * This function is not MT-Safe.
+     * </p>
+     * @param chunk The specified chunk.
+     */
+    public void removeChunk(final Chunk chunk) {
+        final int regionX = ChunkRegionManager.getRegionCoordinate(chunk.locX);
+        final int regionZ = ChunkRegionManager.getRegionCoordinate(chunk.locZ);
+        final long regionKey = ChunkRegionManager.getRegionKey(regionX, regionZ);
+
+        final ChunkRegion region = this.regions.get(regionKey);
+        if (region.chunkConut() == 1) {
+            this.regions.remove(regionKey);
+        } else {
+            region.removeChunk(chunk);
+        }
+    }
+
+    public static class ChunkRegion {
+
+        public final long regionKey;
+        public final ChunkRegionManager regionManager;
+        public final int regionX;
+        public final int regionZ;
+
+        public final RegionChunkList chunkList = new RegionChunkList();
+
+        private final ReentrantLock lock = new ReentrantLock();
+
+        /**
+         * Tasks that need to be executed after releasing the region.
+         */
+        private final ConcurrentLinkedList<Consumer<ChunkRegion>> tasks = new ConcurrentLinkedList<>();
+
+        public ChunkRegion(final ChunkRegionManager regionManager, final int regionX, final int regionZ, final long regionKey) {
+            this.regionManager = regionManager;
+            this.regionX = regionX;
+            this.regionZ = regionZ;
+            this.regionKey = regionKey;
+            this.tasks.preventAdds(); /* Required since an add-blocked queue represents a free region */
+        }
+
+        public void addChunk(final Chunk chunk) {
+            this.chunkList.add(chunk);
+        }
+
+        public void removeChunk(final Chunk chunk) {
+            this.chunkList.remove(chunk);
+        }
+
+        public int chunkConut() {
+            return this.chunkList.size();
+        }
+
+        private void drainTasks() {
+            this.tasks.drain((final Consumer<ChunkRegion> consumer) -> {
+                consumer.accept(ChunkRegion.this);
+            });
+        }
+
+        public void releaseLock() {
+            if (this.lock.getHoldCount() == 1) {
+                /* This is required to prevent a race condition where a task is executed on a tick segment later than it is expected */
+                this.drainTasks();
+                this.tasks.preventAdds();
+                this.drainTasks(); /* Double check */
+            }
+            this.lock.unlock();
+        }
+
+        public void acquireLock() {
+            this.lock.lock();
+            if (this.lock.getHoldCount() == 1) {
+                this.tasks.allowAdds();
+            }
+        }
+
+        public boolean tryAcquireLock() {
+            if (!this.lock.tryLock()) {
+                return false;
+            }
+            if (this.lock.getHoldCount() == 1) {
+                this.tasks.allowAdds();
+            }
+            return true;
+        }
+
+        public boolean executeNonUrgentTask(final Consumer<ChunkRegion> consumer) {
+            for (;;) {
+                /* Either successfully add to wait queue or lock the region */
+                /* Note that order here matters, threads already owning a region should execute its task synchronously! */
+                if (this.tryAcquireLock()) {
+                    consumer.accept(this);
+                    this.releaseLock();
+                    return true;
+                } else if (this.tasks.add(consumer)) {
+                    return false;
+                }
+                /* Failure means retry, one has to eventually work (and we only reach this point due to a rare race condition) */
+            }
+        }
+
+    }
+}
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
new file mode 100644
index 000000000..1f2ce7936
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentArrayQueue.java
@@ -0,0 +1,461 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+import io.github.spottedleaf.concrete.util.IntegerUtil;
+
+import java.lang.invoke.VarHandle;
+import java.util.Arrays;
+
+public final class ConcurrentArrayQueue<E> {
+
+    public static final int NORESIZE_FLAG = (1 << 0);
+    public static final int PEEK_FLAG     = (1 << 1);
+
+    private static final int UINT_MAX = -1;
+    private static final int MAX_INDEX = UINT_MAX >>> 2; /* 1 bit for encoded length, 1 bit for resize flag */
+    private static final int MAX_LENGTH = MAX_INDEX + 1;
+    private static final int INDEX_LENGTH_MASK = MAX_INDEX | MAX_LENGTH;
+
+    private static final int READING_BIT = Integer.MIN_VALUE;
+
+    private Object[] elements; /* access synchronized through indices */
+
+    /* Separate the indices into different cache lines */
+    private final int[] indices = new int[4 * (256 / 4)];
+
+
+    /**
+     * The first element in this queue.
+     */
+    private static final int AVAILABLE_HEAD_INDEX_INDEX = 1 * (256 / 4);
+
+    /**
+     * The ready-to-read last element added to this queue.
+     */
+    private static final int AVAILABLE_TAIL_INDEX_INDEX = 2 * (256 / 4);
+
+    /**
+     * The last element index allocated for writing.
+     */
+    private static final int ALLOCATED_TAIL_INDEX_INDEX = 3 * (256 / 4);
+
+    private static final VarHandle INDICES_HANDLE = ConcurrentUtil.getArrayHandle(int[].class);
+
+    public ConcurrentArrayQueue() {
+        this(32);
+    }
+
+    public ConcurrentArrayQueue(int capacity) {
+        if (capacity < 0 || capacity > MAX_LENGTH) {
+            throw new IllegalArgumentException("Capacity " + capacity + " is out of bounds");
+        } else if (capacity <= 32) {
+            capacity = 32;
+        } else {
+            final int prevCapacity = capacity;
+            capacity = IntegerUtil.roundCeilLog2(capacity);
+            if (capacity > MAX_LENGTH) {
+                throw new IllegalArgumentException("Capacity " + prevCapacity + " is out of bounds");
+            }
+        }
+
+        this.elements = new Object[capacity];
+        INDICES_HANDLE.set(this.indices, AVAILABLE_HEAD_INDEX_INDEX, capacity);
+        INDICES_HANDLE.set(this.indices, AVAILABLE_TAIL_INDEX_INDEX, capacity);
+        INDICES_HANDLE.set(this.indices, ALLOCATED_TAIL_INDEX_INDEX, capacity);
+        /*HEAD_INDEX_HANDLE.set(this, capacity);
+        AVAILABLE_TAIL_INDEX_HANDLE.set(this, capacity);
+        ALLOCATED_TAIL_INDEX_HANDLE.set(this, capacity);*/
+    }
+
+    /* Inclusive head, Exclusive tail */
+    private static int queueLength(final int head, final int tail, final int lengthMask) {
+        return (tail - head) & lengthMask;
+    }
+
+    /* Inclusive head, Exclusive tail */
+    private static int getRemainingLength(final int head, final int tail, final int length) {
+        if (head <= tail) {
+            return length - (tail - head);
+        } else {
+            return (head - tail);
+        }
+    }
+
+    public int capacity() {
+        int failures = 0;
+        for (;;) {
+            //final int tail = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+            final int tail = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return IntegerUtil.roundFloorLog2(tail);
+        }
+    }
+
+    public int size() {
+        int failures = 0;
+        for (;;) {
+            /*int head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+            final int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);*/
+            int head = (int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+            final int tail = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_TAIL_INDEX_INDEX);
+
+            if (head == UINT_MAX) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            head &= INDEX_LENGTH_MASK;
+
+            final int lengthHead = IntegerUtil.roundFloorLog2(head);
+            final int lengthTail = IntegerUtil.roundFloorLog2(tail);
+
+            if (lengthHead != lengthTail) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return queueLength(head ^ lengthHead, tail ^ lengthTail, lengthHead - 1);
+        }
+    }
+
+    public int remainingCapacity() {
+        int failures = 0;
+        for (;;) {
+            /*int head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+            final int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);*/
+            int head = (int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+            final int tail = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_TAIL_INDEX_INDEX);
+
+            if (head == UINT_MAX) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            if (tail == UINT_MAX) {
+                if (++failures > 500) {
+                    failures = 0;
+                    Thread.yield();
+                }
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            head &= INDEX_LENGTH_MASK;
+
+            final int lengthHead = IntegerUtil.roundFloorLog2(head);
+            final int lengthTail = IntegerUtil.roundFloorLog2(tail);
+
+            if (lengthHead != lengthTail) {
+                ConcurrentUtil.pause();
+                continue;
+            }
+
+            return getRemainingLength(head ^ lengthHead, tail ^ lengthTail, lengthHead);
+        }
+    }
+
+    private int acquireHead(final int flags) {
+        int head;
+        if ((flags & NORESIZE_FLAG) != 0) {
+            //head = (int)HEAD_INDEX_HANDLE.getVolatile(this);
+            head = (int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+        } else {
+            for (int failures = 0;;++failures) {
+                //head = (int)HEAD_INDEX_HANDLE.getAndBitwiseOr(this, READING_BIT);
+                head = (int)INDICES_HANDLE.getAndBitwiseOr(this.indices, AVAILABLE_HEAD_INDEX_INDEX, READING_BIT);
+                if ((head & READING_BIT) == 0) {
+                    break;
+                }
+                for (int i = 0; i < failures; ++i) {
+                    ConcurrentUtil.pause();
+                }
+            }
+        }
+        return head;
+    }
+
+    private void releaseHead(final int oldHead, final int newHead, final int length, final int flags) {
+        if ((flags & PEEK_FLAG) != 0) {
+            /* Only write when there is a need to */
+            if ((flags & NORESIZE_FLAG) == 0) {
+                //HEAD_INDEX_HANDLE.setVolatile(this, head | length);
+                INDICES_HANDLE.setVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX, oldHead | length);
+            }
+        } else {
+            //HEAD_INDEX_HANDLE.setVolatile(this, newHead | length);
+            INDICES_HANDLE.setVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX, newHead | length);
+        }
+    }
+
+    public int read(final E[] buffer, final int maxItems, final int flags) {
+        int head = this.acquireHead(flags);
+
+        /* Since writes to tail are seq_cst, and sychronization already occured, tail is pretty up-to-date */
+        /* Use acquire to synchronize with the state at tail's point in time */
+        //int tail = (int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this);
+        int tail = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_TAIL_INDEX_INDEX);
+
+        /* By locking the head it is guaranteed the tail will have the same length as head */
+        final Object[] elements = this.elements;
+
+        final int length = IntegerUtil.roundFloorLog2(head);
+        final int lengthMask = length - 1;
+
+        tail ^= length;
+        head ^= length;
+
+        int itemsToRead = queueLength(head, tail, lengthMask);
+
+        if (itemsToRead >= maxItems) {
+            itemsToRead = maxItems;
+        }
+
+        final int newHead = (head + itemsToRead) & lengthMask;
+
+        if (newHead >= head) {
+            /* Sequential */
+            if (buffer != null) {
+                System.arraycopy(elements, head, (Object[]) buffer, 0, itemsToRead);
+            }
+            if ((flags & PEEK_FLAG) == 0) {
+                Arrays.fill(elements, head, head + itemsToRead, null);
+            }
+        } else {
+            /* Wrapped */
+            final int end = length - head;
+            if ((flags & PEEK_FLAG) != 0) {
+                if (buffer != null) {
+                    System.arraycopy(elements, head, (Object[]) buffer, 0, end);
+                    System.arraycopy(elements, 0, (Object[]) buffer, end, itemsToRead - end);
+                }
+            } else {
+                if (buffer != null) {
+                    System.arraycopy(elements, head, (Object[]) buffer, 0, end);
+                }
+                Arrays.fill(elements, head, head + end, null);
+                if (buffer != null) {
+                    System.arraycopy(elements, 0, (Object[]) buffer, end, itemsToRead - end);
+                }
+                Arrays.fill(elements, 0, itemsToRead - end, null);
+            }
+        }
+
+        this.releaseHead(head, newHead, length, flags);
+
+        return itemsToRead;
+    }
+
+    @SafeVarargs
+    public final int add(final E... elements) {
+        return this.add(elements, 0, elements.length, 0);
+    }
+
+    public int add(final E[] elements, final int off, final int nitems, final int flags) {
+        final int maxLength = MAX_LENGTH;
+
+        if (nitems >= maxLength) {
+            throw new IllegalArgumentException("nitems is too large: " + nitems);
+        }
+
+        int currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+        int failures = 0;
+        for (;;) {
+            /* Exponential backoff */
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+            /* Retrieve current_index after backoff to ensure it's not immediately out-of-date */
+            /* Nevermind this drops perf by 4x */
+            //currentIndex = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+            //currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+
+            if (currentIndex == UINT_MAX) {
+                Thread.yield();
+                //currentIndex = (int)ALLOCATED_TAIL_INDEX_HANDLE.getVolatile(this);
+                currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+            }
+
+            /* Not resizing */
+
+            /* Decode length */
+            final int length = IntegerUtil.roundFloorLog2(currentIndex);
+            final int lengthMask = length - 1;
+
+            final int allocatedStart = currentIndex ^ length; /* Inclusive */
+            final int allocatedEnd = (currentIndex + nitems) & lengthMask; /* Exclusive */
+
+            //final int currentHeadRaw = (int)HEAD_INDEX_HANDLE.getAcquire(this);
+            final int currentHeadRaw = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+
+            /* Validate the indices */
+
+            /*
+             * May not be resizing
+             * Must have equal encoded lengths (otherwise size check is invalid)
+             */
+
+            if (currentHeadRaw == UINT_MAX) {
+                ConcurrentUtil.pause();
+                currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+                continue;
+            }
+            if (IntegerUtil.roundFloorLog2(currentHeadRaw & INDEX_LENGTH_MASK) != length) {
+                ConcurrentUtil.pause();
+                currentIndex = (int)INDICES_HANDLE.getVolatile(this.indices, ALLOCATED_TAIL_INDEX_INDEX);
+                continue;
+            }
+
+            /* Finished validating the head index */
+
+            final int queueStart = currentHeadRaw & lengthMask; /* Inclusive */
+
+            /* Find remaining length to ensure there is enough space */
+            final int remainingLength = getRemainingLength(queueStart, allocatedStart, length);
+
+            if (remainingLength > nitems) {
+                /* space available */
+                //if (!ALLOCATED_TAIL_INDEX_HANDLE.compareAndSet(this, currentIndex, allocatedEnd | length)) {
+                final int prevCurrIndex = currentIndex;
+                if ((currentIndex = (int)INDICES_HANDLE.compareAndExchange(this.indices, ALLOCATED_TAIL_INDEX_INDEX, currentIndex, allocatedEnd | length)) != prevCurrIndex) {
+                    ConcurrentUtil.pause();
+                    ++failures;
+                    continue;
+                }
+
+                final Object[] queuedElements = this.elements;
+                if (allocatedEnd >= allocatedStart) {
+                    /* Sequential */
+                    System.arraycopy((Object[])elements, off, queuedElements, allocatedStart, nitems);
+                } else {
+                    /* Wrapped */
+                    final int end = length - allocatedStart;
+                    System.arraycopy((Object[])elements, off, queuedElements, allocatedStart, end);
+                    System.arraycopy((Object[])elements, off + end, queuedElements, 0, nitems - end);
+                }
+
+                while ((int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_TAIL_INDEX_INDEX) != currentIndex) {
+                    ConcurrentUtil.pause();
+                }
+                //AVAILABLE_TAIL_INDEX_HANDLE.setVolatile(this, allocatedEnd | length);
+                INDICES_HANDLE.setVolatile(this.indices, AVAILABLE_TAIL_INDEX_INDEX, allocatedEnd | length);
+                return length - remainingLength;
+            }
+
+            final int requiredLength = (length - remainingLength) + nitems; /* Exclusive end of queue once resized and copied */
+
+            if ((flags & NORESIZE_FLAG) != 0 || requiredLength >= maxLength) {
+                return -1; /* TODO */
+            }
+
+            /* Attempt to lock allocated_tail_index */
+            //if (!ALLOCATED_TAIL_INDEX_HANDLE.compareAndSet(this, currentIndex, UINT_MAX)) {
+            if (!INDICES_HANDLE.compareAndSet(this.indices, ALLOCATED_TAIL_INDEX_INDEX, currentIndex, UINT_MAX)) {
+                ++failures;
+                continue;
+            }
+
+            /* Add 1 to ensure that the resized queue will not be full */
+            /* It is an error if this queue is full as distinction between a full queue and an empty one is not possible */
+            /* exclusive end == inclusive start for both cases */
+            final int expectedLength = IntegerUtil.roundCeilLog2(requiredLength + 1);
+            final Object[] newElements = new Object[expectedLength];
+            final Object[] currElements = this.elements;
+
+            /* Copy previous elements over */
+            /* Note that while new indices cannot be allocated, some writes to the queue may not be finished */
+            /* wait for previous writes to complete */
+
+            /* Use acquire to acquire with the writes to elements (thus synchronizing with other writers) */
+            //while ((int)AVAILABLE_TAIL_INDEX_HANDLE.getAcquire(this) != currentIndex) {
+            int spinWaitFailures = 0;
+            while ((int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_TAIL_INDEX_INDEX) != currentIndex) {
+                if (spinWaitFailures == 1000) {
+                    spinWaitFailures = 0;
+                    Thread.yield();
+                    /* This will not fix the thread scheduling issues however it should prevent total loss of performance */
+                }
+                ConcurrentUtil.pause();
+                ++spinWaitFailures;
+            }
+
+            /* Copy the elements over */
+
+            /* allocatedStart at this point is now the exclusive end of the queue */
+
+            if (queueStart < allocatedStart) {
+                /* Sequential */
+                System.arraycopy(currElements, queueStart, newElements, 0, length - remainingLength);
+            } else {
+                /* Wrapped */
+                final int end = length - queueStart;
+                System.arraycopy(currElements, queueStart, newElements, 0, end);
+                System.arraycopy(currElements, 0, newElements, end, allocatedStart);
+            }
+
+            /* Copy our elements over */
+
+            System.arraycopy((Object[])elements, off, newElements, length - remainingLength, nitems);
+
+            /* Update head */
+
+            //for (int headcurr = (int)HEAD_INDEX_HANDLE.getVolatile(this);;) {
+            for (int headcurr = (int)INDICES_HANDLE.getVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX);;) {
+                if ((headcurr & READING_BIT) != 0) {
+                    Thread.yield();
+                    headcurr = (int)INDICES_HANDLE.getAcquire(this.indices, AVAILABLE_HEAD_INDEX_INDEX);
+                    continue;
+                }
+                /* Create new head index */
+                /* Elements may have been read during resizing, so we need to re-adjust */
+
+                final int oldHead = queueStart;
+                final int updatedHead = headcurr ^ length;
+
+                final int newHead = queueLength(oldHead, updatedHead, lengthMask) | expectedLength;
+
+                Arrays.fill(newElements, 0, newHead, null); /* Remove read elements */
+
+                /* Try to lock head */
+
+                //if (!HEAD_INDEX_HANDLE.compareAndSet(this, headcurr, UINT_MAX)) {
+                if (!INDICES_HANDLE.compareAndSet(this.indices, AVAILABLE_HEAD_INDEX_INDEX, headcurr, UINT_MAX)) {
+                    ConcurrentUtil.pause();
+                    continue;
+                }
+
+                /* Head is locked */
+                /* Note that this is the only area where reads can block */
+                this.elements = newElements;
+                //AVAILABLE_TAIL_INDEX_HANDLE.set(this, requiredLength | expectedLength);
+                INDICES_HANDLE.set(this.indices, AVAILABLE_TAIL_INDEX_INDEX, remainingLength | expectedLength);
+
+                //ALLOCATED_TAIL_INDEX_HANDLE.setRelease(this, requiredLength | expectedLength);
+                INDICES_HANDLE.setRelease(this.indices, requiredLength | expectedLength);
+
+                //HEAD_INDEX_HANDLE.setVolatile(this, newHead);
+                INDICES_HANDLE.setVolatile(this.indices, AVAILABLE_HEAD_INDEX_INDEX, newHead);
+                /* Unlocked head */
+
+                break;
+            }
+            return length - remainingLength;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
new file mode 100644
index 000000000..359ad1a69
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentLinkedList.java
@@ -0,0 +1,734 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+import java.lang.invoke.VarHandle;
+import java.util.*;
+import java.util.function.Consumer;
+import java.util.function.IntFunction;
+import java.util.function.Predicate;
+
+/**
+ * MT-Safe linked first in first out ordered queue.
+ *
+ * This queue should out-perform {@link java.util.concurrent.ConcurrentLinkedQueue} in high-contention reads/writes, and is
+ * not any slower in lower contention reads/writes.
+ * <p>
+ * Note that this queue breaks the specification laid out by {@link Collection}, see {@link #preventAdds()} and {@link Collection#add(Object)}.
+ * </p>
+ * @param <E> Type of element in this queue.
+ */
+public class ConcurrentLinkedList<E> implements Queue<E> {
+
+    //@jdk.internal.vm.annotation.Contended
+    private volatile LinkedNode<E> head; /* Always non-null, high chance of being the actual head */
+
+    //@jdk.internal.vm.annotation.Contended
+    private volatile LinkedNode<E> tail; /* Always non-null, high chance of being the actual tail */
+
+    /* Note that it is possible to reach head from tail. */
+
+    /* IMPL NOTE: Leave hashCode and equals to their defaults */
+
+    private static final VarHandle HEAD_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentLinkedList.class, "head", LinkedNode.class);
+    private static final VarHandle TAIL_HANDLE = ConcurrentUtil.getVarHandle(ConcurrentLinkedList.class, "tail", LinkedNode.class);
+
+    /**
+     * Constructs a {@code ConcurrentLinkedList}, initially empty.
+     * <p>
+     * The returned object may not be published without synchronization.
+     * </p>
+     */
+    public ConcurrentLinkedList() {
+        final LinkedNode<E> value = new LinkedNode<>(null, null);
+        HEAD_HANDLE.set(this, value);
+        TAIL_HANDLE.set(this, value);
+    }
+
+    /**
+     * Constructs a {@code ConcurrentLinkedList}, initially containing all elements in the specified {@code collection}.
+     * <p>
+     * The returned object may not be published without synchronization.
+     * </p>
+     * @param collection The specified collection.
+     * @throws NullPointerException If {@code collection} is {@code null} or contains {@code null} elements.
+     */
+    public ConcurrentLinkedList(final Collection<? extends E> collection) {
+        final Iterator<? extends E> elements = collection.iterator();
+        if (!elements.hasNext()) {
+            final LinkedNode<E> value = new LinkedNode<>(null, null);
+            HEAD_HANDLE.set(this, value);
+            TAIL_HANDLE.set(this, value);
+            return;
+        }
+
+        final LinkedNode<E> head = new LinkedNode<>(validateNotNull(elements.next()), null);
+        LinkedNode<E> tail = head;
+
+        while (elements.hasNext()) {
+            final LinkedNode<E> next = new LinkedNode<>(validateNotNull(elements.next()), null);
+            LinkedNode.NEXT_HANDLE.set(tail, next);
+            tail = next;
+        }
+
+        HEAD_HANDLE.set(this, head);
+        TAIL_HANDLE.set(this, tail);
+    }
+
+    private static <T> T validateNotNull(final T value) {
+        if (value == null) {
+            throw new NullPointerException();
+        }
+        return value;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E remove() throws NoSuchElementException {
+        final E ret = this.poll();
+        if (ret == null) {
+            throw new NoSuchElementException();
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean add(final E element) {
+        return this.offer(element);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E element() throws NoSuchElementException {
+        final E ret = this.peek();
+        if (ret == null) {
+            throw new NoSuchElementException();
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean offer(final E element) {
+        if (element == null) {
+            throw new NullPointerException();
+        }
+        final LinkedNode<E> node = new LinkedNode<>(element, null);
+        return this.appendList(node, node);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E peek() {
+        return this.getHead(false);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public E poll() {
+        return this.getHead(true);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void clear() {
+        //noinspection StatementWithEmptyBody
+        while (this.poll() != null);
+    }
+
+    /**
+     * Constant time clear operation for this queue. Note that it is possible that some threads reading the queue will not
+     * be updated to this operation. For example, iterators and remove variants will not be notified, and sometimes
+     * peek/poll will not be notified. If there are no concurrent accesses to this queue, then this method will have the
+     * same effect as {@link #clear()}.
+     * @return {@code true} if the queue was cleared, {@code false} otherwise.
+     */
+    public boolean fastClear() {
+        final LinkedNode<E> newHead = new LinkedNode<>(null, null);
+        if (!this.appendList(newHead, newHead)) {
+            return false;
+        }
+        HEAD_HANDLE.setVolatile(this, newHead);
+        return true;
+    }
+
+    /**
+     * Prevents elements from being added to this queue. Once this is called, any attempt to add to this queue will fail.
+     * <p>
+     * This function is MT-Safe.
+     * </p>
+     * @return {@code true} if the queue was modified to prevent additions, {@code false} if it already prevented additions.
+     */
+    public boolean preventAdds() {
+        final LinkedNode<E> deadEnd = new LinkedNode<>(null, null);
+        LinkedNode.NEXT_HANDLE.set(deadEnd, deadEnd);
+        if (!this.appendList(deadEnd, deadEnd)) {
+            return false;
+        }
+        TAIL_HANDLE.setRelease(this, deadEnd); /* Ensure tail is set for the following #allowAdds call */
+        return true;
+    }
+
+    /**
+     * Allows elements to be added to this queue once again. Note that this function has undefined behaviour if
+     * {@link #preventAdds()} is not called beforehand.
+     * <p>
+     * This function is not MT-Safe.
+     * </p>
+     */
+    public void allowAdds() {
+        //noinspection unchecked
+        LinkedNode.NEXT_HANDLE.setVolatile(((LinkedNode<E>)TAIL_HANDLE.get(this)), null);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean remove(final Object object) {
+        if (object == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                if ((element == object || element.equals(object))
+                        && LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) == element) {
+                    return true;
+                }
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeIf(final Predicate<? super E> filter) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                //noinspection unchecked
+                ret |= filter.test((E) element) && LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) == element;
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeAll(final Collection<?> collection) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                ret |= collection.contains(element) && LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) == element;
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean retainAll(final Collection<?> collection) {
+        boolean ret = false;
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                ret |= !collection.contains(element) && LinkedNode.ELEMENT_HANDLE.getAndSet( curr, null) == element;
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+        return ret;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Object[] toArray() {
+        final List<E> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                //noinspection unchecked
+                ret.add((E) element);
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+
+        return ret.toArray();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> T[] toArray(final T[] array) {
+        final List<T> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                //noinspection unchecked
+                ret.add((T) element);
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+
+        return ret.toArray(array);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public <T> T[] toArray(final IntFunction<T[]> generator) {
+        final List<T> ret = new ArrayList<>();
+
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                //noinspection unchecked
+                ret.add((T) element);
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+
+        return ret.toArray(generator);
+    }
+
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public String toString() {
+        final StringBuilder builder = new StringBuilder();
+
+        builder.append("ConcurrentLinkedList: {elements: {");
+
+        int deadEntries = 0;
+        int totalEntries = 0;
+        int aliveEntries = 0;
+
+        for (LinkedNode<E> curr = this.head;; ++totalEntries) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element == null) {
+                ++deadEntries;
+            } else {
+                ++aliveEntries;
+            }
+
+            if (totalEntries != 0) {
+                builder.append(", ");
+            }
+
+            builder.append(totalEntries).append(": \"").append(element).append('"');
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+
+        }
+
+        builder.append("}, total_entries: \"").append(totalEntries).append("\", alive_entries: \"").append(aliveEntries)
+                .append("\", dead_entries:").append(deadEntries).append("\"}");
+
+        return builder.toString();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean addAll(final Collection<? extends E> collection) {
+        final Iterator<? extends E> elements = collection.iterator();
+        if (!elements.hasNext()) {
+            return false;
+        }
+
+        /* Build a list of nodes to append */
+        /* This is an order of magnitudes faster due to the fact that zero synchronization is performed */
+
+        final LinkedNode<E> head = new LinkedNode<>(validateNotNull(elements.next()), null);
+        LinkedNode<E> tail = head;
+
+        while (elements.hasNext()) {
+            final LinkedNode<E> next = new LinkedNode<>(validateNotNull(elements.next()), null);
+            LinkedNode.NEXT_HANDLE.set(tail, next);
+            tail = next;
+        }
+
+        return this.appendList(head, tail);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean containsAll(final Collection<?> collection) {
+        for (final Object element : collection) {
+            if (!this.contains(element)) {
+                return false;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Iterator<E> iterator() {
+        return new LinkedIterator<>(this.head);
+    }
+
+    /**
+     * {@inheritDoc}
+     * <p>
+     * Note that this function is computed non-atomically and in O(n) time. The value returned may not be representative of
+     * the queue in its current state.
+     * </p>
+     */
+    @Override
+    public int size() {
+        int size = 0;
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                ++size;
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+        return size;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isEmpty() {
+        return this.peek() != null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean contains(final Object object) {
+        if (object == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null && (element == object || element.equals(object))) {
+                return true;
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void forEach(final Consumer<? super E> action) {
+        if (action == null) {
+            throw new NullPointerException();
+        }
+        for (LinkedNode<E> curr = this.head;;) {
+            final Object element = LinkedNode.ELEMENT_HANDLE.getAcquire(curr); /* Likely in sync */
+            if (element != null) {
+                //noinspection unchecked
+                action.accept((E) element);
+            }
+
+            final LinkedNode<E> next = curr.next;
+            if (next == null || next == curr) {
+                break;
+            }
+        }
+    }
+
+    private boolean appendList(final LinkedNode<E> head, final LinkedNode<E> tail) {
+        int failures = 0;
+
+        for (LinkedNode<E> currTail = this.tail, curr = currTail;;) {
+            /* It has been experimentally shown that placing the read before the backoff results in significantly greater performance */
+            /* It is likely due to false sharing */
+            final LinkedNode<E> next = curr.next;
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+            if (next == null) {
+                //noinspection unchecked
+                final LinkedNode<E> compared = (LinkedNode<E>) LinkedNode.NEXT_HANDLE.compareAndExchange(curr, null, head);
+
+                if (compared == null) {
+                    /* Added */
+                    if (curr != currTail) {
+                        /* Avoid CASing on tail more than we need to */
+                        /* CAS to avoid setting an out-of-date tail */
+                        TAIL_HANDLE.compareAndExchange(this, currTail, tail);
+                    }
+                    return true;
+                }
+
+                ++failures;
+                curr = compared;
+                continue;
+            } else if (next == curr) {
+                /* Additions are stopped */
+                return false;
+            }
+
+            if (curr == currTail) {
+                /* Tail is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to tail */
+                if (currTail == (currTail = this.tail)) {
+                    curr = next;
+                } else {
+                    curr = currTail;
+                }
+            }
+        }
+    }
+
+    private E getHead(final boolean remove) {
+        int failures = 0;
+        for (LinkedNode<E> head = this.head, curr = head;;) {
+            final Object currentVal = curr.element;
+            //noinspection unchecked
+            final LinkedNode<E> next = (LinkedNode<E>) LinkedNode.NEXT_HANDLE.getAcquire(curr);
+            for (int i = 0; i < failures; ++i) {
+                ConcurrentUtil.pause();
+            }
+
+            if (currentVal != null) {
+                if (!remove) {
+                    return (E) currentVal;
+                }
+                if (!LinkedNode.ELEMENT_HANDLE.compareAndSet(curr, currentVal, null)) {
+                    /* Failed to get head */
+                    ++failures;
+                    if (curr == (curr = curr.next)) {
+                        return null;
+                    }
+                    continue;
+                }
+
+                if (next != null) {
+                    /* Try to set head to the latest value */
+                    curr = next;
+                }
+
+                if (head != curr) {
+                    /* Avoid CASing on head more than we need to */
+                    /* CAS to avoid setting an out-of-date head */
+                    HEAD_HANDLE.compareAndExchange(this, head, curr);
+                }
+                return (E) currentVal;
+            }
+
+            if (next == null) {
+                return null; /* End of queue */
+            }
+
+            if (head == curr) {
+                /* head is likely not up-to-date */
+                curr = next;
+            } else {
+                /* Try to update to head */
+                if (head == (head = this.head)) {
+                    curr = next;
+                } else {
+                    curr = head;
+                }
+            }
+        }
+    }
+
+    /**
+     * Empties the queue into the specified consumer. This function is optimized for single-threaded reads, and should
+     * be faster than a loop on {@link #poll()}.
+     * <p>
+     * This function is not MT-Safe. This function cannot be called with other read operations ({@link #peek()}, {@link #poll()},
+     * {@link #clear()}, {@link #fastClear()}, etc).
+     * Write operations are safe to be called concurrently.
+     * </p>
+     * @param consumer The consumer to accept the elements.
+     */
+    public void drain(final Consumer<E> consumer) {
+        //noinspection unchecked
+        LinkedNode<E> curr = (LinkedNode<E>) HEAD_HANDLE.getVolatile(this);
+        for (;;) {
+            final Object currentVal = LinkedNode.ELEMENT_HANDLE.get(curr);
+
+            /* Make sure to acquire with the write to the element field */
+            //noinspection unchecked
+            final LinkedNode<E> next = (LinkedNode<E>) LinkedNode.NEXT_HANDLE.getAcquire(curr);
+            if (next == curr) {
+                break;
+            }
+            if (currentVal == null) {
+                curr = next;
+                continue;
+            }
+            /* Since there are no reads concurrently they will just synchronize with these plain writes after reading head */
+            LinkedNode.ELEMENT_HANDLE.set(curr, null);
+            curr = next;
+
+            //noinspection unchecked
+            consumer.accept((E) currentVal);
+            if (next == null) {
+                break;
+            }
+        }
+        HEAD_HANDLE.setVolatile(this, curr);
+    }
+
+    private static final class LinkedNode<E> {
+
+        private volatile Object element;
+        private volatile LinkedNode<E> next;
+
+        private static final VarHandle ELEMENT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "element", Object.class);
+        private static final VarHandle NEXT_HANDLE = ConcurrentUtil.getVarHandle(LinkedNode.class, "next", LinkedNode.class);
+
+        LinkedNode(final Object element, final LinkedNode<E> next) {
+            ELEMENT_HANDLE.set(this, element);
+            NEXT_HANDLE.set(this, next);
+        }
+
+    }
+
+    private static final class LinkedIterator<E> implements Iterator<E> {
+
+        private LinkedNode<E> curr;
+        private E next;
+
+        LinkedIterator(final LinkedNode<E> head) {
+            this.curr = head;
+        }
+
+        /* sets next to the next value, or null if empty */
+        private void findNext() {
+            LinkedNode<E> curr = this.curr;
+            for (;curr != null;) {
+                //noinspection unchecked
+                final E element = (E) LinkedNode.ELEMENT_HANDLE.getAcquire(curr);
+                if (element != null) {
+                    this.curr = curr;
+                    this.next = element;
+                    return;
+                }
+                final LinkedNode<E> next = curr.next;
+                if (next == curr) {
+                    break;
+                }
+                curr = next;
+            }
+            /* reached end of list */
+            this.curr = null;
+            this.next = null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean hasNext() {
+            if (this.next == null) {
+                this.findNext();
+            }
+            return this.next == null;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public E next() {
+            if (!this.hasNext()) {
+                throw new NoSuchElementException();
+            }
+            return this.next;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void remove() {
+            if (this.next == null) {
+                throw new IllegalStateException();
+            }
+            LinkedNode.ELEMENT_HANDLE.setVolatile(this.curr, null);
+            this.next = null;
+        }
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
new file mode 100644
index 000000000..79615254d
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/concurrent/ConcurrentUtil.java
@@ -0,0 +1,39 @@
+package io.github.spottedleaf.concrete.concurrent;
+
+
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
+
+public final class ConcurrentUtil {
+
+    /**
+     * Closest possible implementation of the x86 PAUSE instruction.
+     */
+    public static void pause() {
+        Thread.onSpinWait();
+    }
+
+    public static VarHandle getVarHandle(final Class<?> lookIn, final String fieldName, final Class<?> fieldType) {
+        try {
+            return MethodHandles.privateLookupIn(lookIn, MethodHandles.lookup()).findVarHandle(lookIn, fieldName, fieldType);
+        } catch (final Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public static VarHandle getStaticVarHandle(final Class<?> lookIn, final String fieldName, final Class<?> fieldType) {
+        try {
+            return MethodHandles.privateLookupIn(lookIn, MethodHandles.lookup()).findStaticVarHandle(lookIn, fieldName, fieldType);
+        } catch (final Exception ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    public static VarHandle getArrayHandle(final Class<?> type) {
+        return MethodHandles.arrayElementVarHandle(type);
+    }
+
+    private ConcurrentUtil() {
+        throw new RuntimeException();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java b/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java
new file mode 100644
index 000000000..81f974cb2
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/util/IntegerUtil.java
@@ -0,0 +1,52 @@
+package io.github.spottedleaf.concrete.util;
+
+public class IntegerUtil {
+
+    public static final int HIGH_BIT_U32 = Integer.MIN_VALUE;
+    public static final long HIGH_BIT_U64 = Long.MIN_VALUE;
+
+    public static int ceilLog2(final int value) {
+        return 32 - Integer.numberOfLeadingZeros(value - 1);
+    }
+
+    public static long ceilLog2(final long value) {
+        return 64 - Long.numberOfLeadingZeros(value - 1);
+    }
+
+    public static int floorLog2(final int value) {
+        return 31 ^ Integer.numberOfLeadingZeros(value);
+    }
+
+    public static int floorLog2(final long value) {
+        return 63 ^ Long.numberOfLeadingZeros(value);
+    }
+
+    public static int roundCeilLog2(final int value) {
+        return HIGH_BIT_U32 >>> (Integer.numberOfLeadingZeros(value - 1) - 1);
+    }
+
+    public static long roundCeilLog2(final long value) {
+        return HIGH_BIT_U64 >>> (Long.numberOfLeadingZeros(value - 1) - 1);
+    }
+
+    public static int roundFloorLog2(final int value) {
+        return HIGH_BIT_U32 >>> Integer.numberOfLeadingZeros(value);
+    }
+
+    public static long roundFloorLog2(final long value) {
+        return HIGH_BIT_U64 >>> Long.numberOfLeadingZeros(value);
+    }
+
+    public static boolean isPowerOfTwo(final int n) {
+        return (-n & n) == n;
+    }
+
+    public static boolean isPowerOfTwo(final long n) {
+        return (-n & n) == n;
+    }
+
+    private IntegerUtil() {
+        throw new RuntimeException();
+    }
+
+}
diff --git a/src/main/java/io/github/spottedleaf/concrete/util/RegionChunkList.java b/src/main/java/io/github/spottedleaf/concrete/util/RegionChunkList.java
new file mode 100644
index 000000000..c0b66231b
--- /dev/null
+++ b/src/main/java/io/github/spottedleaf/concrete/util/RegionChunkList.java
@@ -0,0 +1,86 @@
+package io.github.spottedleaf.concrete.util;
+
+import io.github.spottedleaf.concrete.chunk.ChunkRegionManager;
+import net.minecraft.server.Chunk;
+
+import java.util.function.Consumer;
+
+public class RegionChunkList {
+
+    private final long[] keyset = new long[ChunkRegionManager.REGION_WIDTH * ChunkRegionManager.REGION_WIDTH / Long.SIZE];
+
+    private final Chunk[] chunks = new Chunk[ChunkRegionManager.REGION_WIDTH * ChunkRegionManager.REGION_WIDTH];
+
+    private int size;
+
+    public int size() {
+        return this.size;
+    }
+
+    public void add(final Chunk chunk) {
+        final int x = chunk.locX & (ChunkRegionManager.REGION_WIDTH - 1);
+        final int z = chunk.locZ & (ChunkRegionManager.REGION_WIDTH - 1);
+
+        final int arrayIndex = (z << 4) | x;
+
+        final int keysetIndex = z >>> 2;
+        final int keysetBitfield = ((z & 0xF) << 4) | x;
+
+        final long chunkField = 1 << keysetBitfield;
+        long curr = this.keyset[keysetIndex];
+        if (curr == (curr |= chunkField)) {
+            throw new IllegalStateException("Already contains chunk (" + x + "," + z + ")");
+        }
+
+        this.keyset[keysetIndex] = curr;
+        this.chunks[arrayIndex] = chunk;
+        ++this.size;
+    }
+
+    public Chunk getChunk(final int chunkX, final int chunkZ) {
+        final int x = chunkX & (ChunkRegionManager.REGION_WIDTH - 1);
+        final int z = chunkZ & (ChunkRegionManager.REGION_WIDTH - 1);
+        return this.chunks[(z << 4) | x];
+    }
+
+    public Chunk remove(final Chunk chunk) {
+        return this.remove(chunk.locX, chunk.locZ);
+    }
+
+    public Chunk remove(final int chunkX, final int chunkZ) {
+        final int x = chunkX & (ChunkRegionManager.REGION_WIDTH - 1);
+        final int z = chunkZ & (ChunkRegionManager.REGION_WIDTH - 1);
+
+        final int arrayIndex = (z << 4) | x;
+
+        final int keysetIndex = z >>> 2;
+        final int keysetBitfield = ((z & 0xF) << 4) | x;
+
+        final long chunkField = 1 << keysetBitfield;
+        long curr = this.keyset[keysetIndex];
+        if (curr < (curr ^= chunkField)) {
+            /* If the chunk isn't mapped, then the XOR op will add a bitfield to the current value thus causing the value to be greater-than previous */
+            throw new IllegalStateException("Does not contain chunk (" + x + "," + z + ")");
+        }
+
+        this.keyset[keysetIndex] = curr;
+
+        final Chunk ret = this.chunks[arrayIndex];
+        this.chunks[arrayIndex] = null;
+        --this.size;
+        return ret;
+    }
+
+    public void forEach(final Consumer<Chunk> consumer) {
+        for (int i = 0; i < this.keyset.length; ++i) {
+            long curr = this.keyset[i];
+            final int offset = i << 6;
+            while (curr != 0) {
+                final int trailing = Long.numberOfTrailingZeros(curr);
+                curr ^= (1 << trailing);
+                consumer.accept(this.chunks[offset + trailing]);
+            }
+        }
+    }
+
+}
\ No newline at end of file
-- 
2.20.1

